[{"content":"\n","date":"2024-10-12T00:00:00Z","image":"https://gkxgithub.github.io/p/%E7%BE%8E/8e071cae5ea4815582903fccfc46a39_hu5531098368616869691.jpg","permalink":"https://gkxgithub.github.io/p/%E7%BE%8E/","title":"美"},{"content":"pom.xm文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 \u0026lt;?xml version=\u0026#34;1.0\u0026#34; encoding=\u0026#34;UTF-8\u0026#34;?\u0026gt; \u0026lt;project xmlns=\u0026#34;http://maven.apache.org/POM/4.0.0\u0026#34; xmlns:xsi=\u0026#34;http://www.w3.org/2001/XMLSchema-instance\u0026#34; xsi:schemaLocation=\u0026#34;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd\u0026#34;\u0026gt; \u0026lt;modelVersion\u0026gt;4.0.0\u0026lt;/modelVersion\u0026gt; \u0026lt;parent\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-parent\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.4.5\u0026lt;/version\u0026gt; \u0026lt;relativePath/\u0026gt; \u0026lt;!-- lookup parent from repository --\u0026gt; \u0026lt;/parent\u0026gt; \u0026lt;groupId\u0026gt;com.itheima\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;reggie_take_out\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.0-SNAPSHOT\u0026lt;/version\u0026gt; \u0026lt;properties\u0026gt; \u0026lt;java.version\u0026gt;1.8\u0026lt;/java.version\u0026gt; \u0026lt;/properties\u0026gt; \u0026lt;dependencies\u0026gt; \u0026lt;!--阿里云短信服务--\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.aliyun\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;aliyun-java-sdk-core\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;4.5.16\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.aliyun\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;aliyun-java-sdk-dysmsapi\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.1.0\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-test\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;test\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-starter-web\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;compile\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.baomidou\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mybatis-plus-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;3.4.2\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;org.projectlombok\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;lombok\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.18.20\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;fastjson\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.2.76\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;commons-lang\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;commons-lang\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.6\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;mysql\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;mysql-connector-java\u0026lt;/artifactId\u0026gt; \u0026lt;scope\u0026gt;runtime\u0026lt;/scope\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;dependency\u0026gt; \u0026lt;groupId\u0026gt;com.alibaba\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;druid-spring-boot-starter\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;1.1.23\u0026lt;/version\u0026gt; \u0026lt;/dependency\u0026gt; \u0026lt;/dependencies\u0026gt; \u0026lt;build\u0026gt; \u0026lt;plugins\u0026gt; \u0026lt;plugin\u0026gt; \u0026lt;groupId\u0026gt;org.springframework.boot\u0026lt;/groupId\u0026gt; \u0026lt;artifactId\u0026gt;spring-boot-maven-plugin\u0026lt;/artifactId\u0026gt; \u0026lt;version\u0026gt;2.4.5\u0026lt;/version\u0026gt; \u0026lt;/plugin\u0026gt; \u0026lt;/plugins\u0026gt; \u0026lt;/build\u0026gt; \u0026lt;/project\u0026gt; yml文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 server: port: 8080 spring: application: # 应用的名称，可选 name: reggie_take_out datasource: druid: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/reggie?serverTimezone=Asia/Shanghai\u0026amp;useUnicode=true\u0026amp;characterEncoding=utf-8\u0026amp;zeroDateTimeBehavior=convertToNull\u0026amp;useSSL=false\u0026amp;allowPublicKeyRetrieval=true username: root password: 123456 mybatis-plus: configuration: #在映射实体或者属性时，将数据库中表名和字段名中的下划线去掉，按照驼峰命名法映射 map-underscore-to-camel-case: true log-impl: org.apache.ibatis.logging.stdout.StdOutImpl global-config: db-config: id-type: ASSIGN_ID reggie: path: D:\\ 就配置了个端口，连接池，mybatisp\n启动类 1 2 3 4 5 6 7 8 9 10 @Slf4j @SpringBootApplication @ServletComponentScan @EnableTransactionManagement public class ReggieApplication { public static void main(String[] args) { SpringApplication.run(ReggieApplication.class,args); log.info(\u0026#34;项目启动成功...\u0026#34;); } } @ServletComponentScan @ServletComponentScan 是 Spring Framework 提供的一个注解，它用于在 Spring Boot 应用中自动扫描并注册 Servlet、Filter 和 Listener 组件。这个注解可以替代传统的在 web.xml 文件中配置 Servlet、Filter 和 Listener 的方式，使得配置更加简洁和灵活。\n作用\n在 Spring Boot 应用的启动类（通常是带有 @SpringBootApplication 注解的类）上使用 @ServletComponentScan 注解后，Spring Boot 会在启动时自动扫描并注册所有带有 @WebServlet（控制器）、@WebFilter（过滤器）、@WebListener（监听器）注解的类。这些类将作为 Servlet、Filter 和 Listener 组件被注册到 Servlet 容器中，从而无需手动在 web.xml 文件中进行配置。\n使用方式\n要在 Spring Boot 应用中使用 @ServletComponentScan 注解，只需在启动类上添加该注解即可。例如：\n1 2 3 4 5 6 7 @SpringBootApplication @ServletComponentScan public class MyApplication { public static void main(String[] args) { SpringApplication.run(MyApplication.class, args); } } 注意事项\n扫描范围：@ServletComponentScan 默认扫描启动类所在的包以及子包。如果需要扫描其他包，可以通过设置 @ServletComponentScan 注解的 basePackages 或 basePackageClasses 属性来指定扫描的包。 类名约定：虽然 Spring Boot 不强制要求 Servlet、Filter 和 Listener 类的命名必须遵循特定规则，但按照惯例，这些类的名称通常会以 Servlet、Filter 或 Listener 结尾，以便于识别和区分。 依赖注入：使用 @WebServlet、@WebFilter 和 @WebListener 注解的类通常不由 Spring 容器管理，因此它们无法自动注入 Spring 管理的 Bean。如果需要在这些组件中使用 Spring 的依赖注入功能，可能需要通过其他方式（如使用 ServletContextListener 或 Spring 的 ApplicationListener）来手动设置这些依赖。 总结\n@ServletComponentScan 注解为 Spring Boot 应用提供了一种简洁和灵活的方式来配置 Servlet、Filter 和 Listener 组件。通过使用该注解，开发者可以避免手动在 web.xml 文件中进行繁琐的配置，从而提高开发效率和应用的可维护性。\n@EnableTransactionManagement 是 Spring Framework 提供的一个注解，用于启用声明式事务管理。当你在 Spring 应用中使用了这个注解后，Spring 容器会寻找带有 @Transactional 注解的 bean，并为它们创建代理，以便在方法执行时管理事务。\n@EnableTransactionManagement 启用事务管理：@EnableTransactionManagement 注解告诉 Spring 容器，应用将使用声明式事务管理。这意味着你可以通过在方法或类上使用 @Transactional 注解来声明事务的边界和规则。 自动代理：Spring 会自动为那些带有 @Transactional 注解的 bean 创建代理。这些代理会在方法调用前后执行必要的事务管理逻辑，如开启事务、提交事务或回滚事务。 配置事务管理器：虽然 @EnableTransactionManagement 本身不直接配置事务管理器，但它会触发 Spring 查找并注册一个事务管理器 bean。通常，你需要通过 Java 配置或 XML 配置来定义一个 PlatformTransactionManager 类型的 bean。 使用方式\n要在 Spring 应用中使用 @EnableTransactionManagement 注解，你只需在配置类上添加该注解即可。例如：\n1 2 3 4 5 6 7 8 9 10 11 @Configuration @EnableTransactionManagement public class TransactionConfig { // 配置事务管理器 @Bean public PlatformTransactionManager transactionManager(EntityManagerFactory emf) { return new JpaTransactionManager(emf); } // 其他配置... } 在这个例子中，TransactionConfig 是一个配置类，它使用了 @EnableTransactionManagement 注解来启用事务管理，并通过 @Bean 注解定义了一个 JpaTransactionManager 类型的 bean 作为事务管理器。\n注意事项\n事务管理器类型：你需要根据你的持久化技术（如 JPA、JDBC、Hibernate 等）选择适当的事务管理器类型。 代理类型：Spring 支持两种代理类型：JDK 动态代理和 CGLIB 代理。默认情况下，如果目标 bean 实现了至少一个接口，Spring 将使用 JDK 动态代理。如果目标 bean 没有实现任何接口，Spring 将使用 CGLIB 代理。你可以通过 @EnableTransactionManagement 注解的 proxyTargetClass 属性来显式指定代理类型。 事务传播行为：在 @Transactional 注解中，你可以指定事务的传播行为、隔离级别、超时时间等属性来控制事务的行为。 总结\n@EnableTransactionManagement 注解是 Spring 框架中用于启用声明式事务管理的重要注解。通过使用该注解，并结合 @Transactional 注解，你可以轻松地在 Spring 应用中实现事务管理，从而提高数据的一致性和完整性。\n@SpringBootApplication @SpringBootApplication 注解是 Spring Boot 项目的核心注解，它结合了多个其他 Spring 框架中的注解，以简化 Spring Boot 应用的配置。这个注解主要用于 Spring Boot 应用的主类上，以快速启动并配置应用。具体来说，@SpringBootApplication 注解执行了以下关键操作：\n定义配置类\n：\n@SpringBootApplication 实际上是 @Configuration 的一个特殊形式，用于定义配置类。在 Spring 中，@Configuration 类使用 @Bean 注解来定义和初始化对象，这些对象随后会被 Spring 容器管理。 @SpringBootConfiguration 不仅声明了当前类是一个配置类，还使得该类能够使用 Spring Boot 特有的自动配置功能。 启用自动配置\n：\n@EnableAutoConfiguration 注解内部包含了 @AutoConfigurationPackage，这个注解的作用是帮助 Spring Boot 找到主配置类所在的包，进而找到当前项目中有哪些配置类，并将它们返回给 Spring 容器。 @EnableAutoConfiguration 注解还借助 @Import(AutoConfigurationImportSelector.class) 的支持，收集和注册特定场景相关的 bean 定义。它会自动根据项目中添加的 jar 依赖来配置 Spring 应用。例如，如果检测到 classpath 中有 H2 数据库驱动，Spring Boot 就会自动配置一个嵌入式 H2 数据库。 启用组件扫描\n：\n@ComponentScan 注解用于启用组件扫描。当它被使用时，Spring Boot 会自动扫描当前包及其子包下的所有组件（如使用 @Component、@Service、@Repository、@Controller 等注解的类），并将这些组件注册为 Spring 应用上下文中的 bean。 通过这种方式，开发者无需显式地在配置类中定义每一个 bean，Spring Boot 会自动发现并管理这些 bean。 元注解功能\n：\n@SpringBootApplication 还使用了 @Documented、@Inherited、@Retention(RetentionPolicy.RUNTIME) 和 @Target(ElementType.TYPE) 等元注解，这些注解提供了关于 @SpringBootApplication 注解本身的额外信息，如文档记录、继承行为、保留策略和适用目标等。 允许自定义配置\n：\n@SpringBootApplication 注解还允许开发者通过其属性进行自定义配置。例如，使用 exclude 属性可以排除特定的自动配置类，以避免不需要的自动配置。 综上所述，@SpringBootApplication 注解通过结合多个 Spring 框架的注解，简化了 Spring Boot 应用的配置过程。它使得开发者能够快速地启动并运行一个 Spring Boot 应用，而无需进行大量的手动配置。在使用 @SpringBootApplication 注解时，主类通常放在根包名下，以确保能够扫描到所有的组件。\nWebMvcConfig 将文件和路径进行了映射处理，并且扩展了消息转换器。\n利用@Configuration注解，将其被Spring Boot自动扫描并加载到容器中，但是这一过程需要满足条件，如果配置类不在默认扫描的包路径下，可以通过在启动类上添加@ComponentScan注解来指定额外的扫描路径。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 @Slf4j @Configuration public class WebMvcConfig extends WebMvcConfigurationSupport { /** * 设置静态资源映射 * @param registry */ @Override protected void addResourceHandlers(ResourceHandlerRegistry registry) { log.info(\u0026#34;开始进行静态资源映射...\u0026#34;); registry.addResourceHandler(\u0026#34;/backend/**\u0026#34;).addResourceLocations(\u0026#34;classpath:/backend/\u0026#34;); registry.addResourceHandler(\u0026#34;/front/**\u0026#34;).addResourceLocations(\u0026#34;classpath:/front/\u0026#34;); } /** * 扩展mvc框架的消息转换器 * @param converters */ @Override protected void extendMessageConverters(List\u0026lt;HttpMessageConverter\u0026lt;?\u0026gt;\u0026gt; converters) { log.info(\u0026#34;扩展消息转换器...\u0026#34;); //创建消息转换器对象 MappingJackson2HttpMessageConverter messageConverter = new MappingJackson2HttpMessageConverter(); //设置对象转换器，底层使用Jackson将Java对象转为json messageConverter.setObjectMapper(new JacksonObjectMapper()); //将上面的消息转换器对象追加到mvc框架的转换器集合中 converters.add(0,messageConverter); } } WebMvcConfigurationSupport 在Spring MVC或Spring Boot MVC项目中，选择继承WebMvcConfigurationSupport类通常是为了实现自定义的Web MVC配置。这个类提供了许多可重写的方法，允许开发者根据需要对Spring MVC的默认行为进行定制。以下是关于继承WebMvcConfigurationSupport类的详细解答：\n为什么要继承WebMvcConfigurationSupport类？\n自定义配置：通过继承WebMvcConfigurationSupport类，开发者可以重写其中的方法来实现自定义的Web MVC配置。例如，可以添加自定义的拦截器、消息转换器、视图解析器等。 覆盖默认配置：在Spring Boot中，默认情况下会使用WebMvcAutoConfiguration类进行自动配置。然而，当开发者继承WebMvcConfigurationSupport类并实现自定义配置时，这种自动配置会被禁用。这意味着开发者可以完全控制Web MVC的配置，而无需受到Spring Boot默认配置的限制。 WebMvcConfigurationSupport类的作用\n提供基础配置：WebMvcConfigurationSupport类是Spring MVC配置的基础类，它提供了一系列与Web MVC相关的配置方法。这些方法包括添加拦截器、配置消息转换器、设置视图解析器等。 支持自定义扩展：通过重写WebMvcConfigurationSupport类中的方法，开发者可以根据项目需求进行自定义扩展。例如，可以添加额外的拦截器来处理特定的请求，或者配置自定义的消息转换器来处理不同类型的HTTP请求和响应。 如何使用WebMvcConfigurationSupport类？\n创建配置类：首先，需要创建一个新的配置类，并使其继承WebMvcConfigurationSupport类。 重写方法：在配置类中，根据需要重写WebMvcConfigurationSupport类中的方法。例如，如果希望添加自定义的拦截器，可以重写addInterceptors方法。 添加注解：在配置类上添加@Configuration注解，以将其标记为Spring的配置类。此外，由于WebMvcConfigurationSupport类本身没有被打上@Configuration注解，因此需要在自定义的配置类上显式添加该注解。 启动应用：完成配置后，启动Spring Boot应用。此时，自定义的Web MVC配置将生效，并覆盖Spring Boot的默认配置。 需要注意的是，一旦选择了继承WebMvcConfigurationSupport类来实现自定义配置，就意味着放弃了Spring Boot提供的Web MVC自动配置。因此，在重写方法时需要谨慎考虑，确保不会引入不必要的复杂性或影响应用的性能。如果只需要对默认配置进行简单的修改或扩展，建议使用实现WebMvcConfigurer接口的方式，这种方式可以在保留Spring Boot自动配置的基础上添加自定义配置。\n@Configuration 在Spring Boot项目中，带有@Configuration注解的类通常会被Spring Boot自动扫描并加载到容器中，但这一过程还需满足一些基本条件。以下是对这一问题的详细解答：\n基本条件\n注解的使用：类上必须明确标注@Configuration注解，以声明该类为配置类。 包扫描：默认情况下，Spring Boot会从启动类所在的包及其子包开始扫描带有@Component、@Service、@Repository、@Controller以及@Configuration等注解的类。因此，如果配置类位于这些默认扫描的包路径下，则无需额外操作。 非抽象类：带有@Configuration注解的类必须是非抽象的，因为Spring需要实例化这些类以创建Bean。 额外操作（如有必要）\n指定扫描路径：如果配置类不在默认扫描的包路径下，可以通过在启动类上添加@ComponentScan注解来指定额外的扫描路径。例如： 1 2 3 4 5 6 7 @SpringBootApplication @ComponentScan(basePackages = {\u0026#34;com.example.config\u0026#34;, \u0026#34;com.another.package\u0026#34;}) public class MyApplication { public static void main(String[] args) { SpringApplication.run(MyApplication.class, args); } } 导入配置类：如果配置类位于不同的模块或项目中，并且不希望或不能通过包扫描来加载，可以使用@Import注解在启动类或另一个配置类中导入这些配置类。例如： 1 2 3 4 5 6 7 @SpringBootApplication @Import(ExternalConfig.class) public class MyApplication { public static void main(String[] args) { SpringApplication.run(MyApplication.class, args); } } 其中，ExternalConfig是一个位于不同模块或项目中的配置类。\n启用特定配置：在某些情况下，可能需要通过@Enable系列注解来启用特定的配置或功能。例如，@EnableWebMvc用于启用Spring MVC配置，@EnableTransactionManagement用于启用声明式事务管理等。这些注解通常与特定的配置类结合使用。 总结\n通常情况下，只要满足基本条件（注解的使用、包扫描、非抽象类），带有@Configuration注解的类就会被Spring Boot自动扫描并加载到容器中。如果配置类位于非默认扫描路径下或需要跨模块/项目导入，则需要进行额外的操作来指定扫描路径或导入配置类。\n检查是否登录的过滤器 其实此处可以利用TOKEN、JWT，可以参考面试篇查看。\n利用@WebFilter将类指定为过滤器，并且已经对启动类进行配置，对带有此注解的类进行扫描了。\n重写doFilter方法，对于将参数进行强转了：\nJava的Servlet过滤器（Filter）的doFilter方法中，传入的ServletRequest和ServletResponse对象通常是HttpServletRequest和HttpServletResponse的父类实例，但实际上在Web应用程序中，我们通常处理的是HTTP请求和响应，这意味着我们更关心这些对象的HTTP特定属性和方法。\n具体来说，当你想要访问请求中的HTTP头部、参数、会话（session）等信息，或者想要控制HTTP响应的状态码、设置头部、发送内容等时，你会需要使用HttpServletRequest和HttpServletResponse接口中定义的方法。\n由于Java是静态类型语言，你不能直接在ServletRequest或ServletResponse对象上调用这些接口中的方法，因为它们没有这些方法（这些方法只在HttpServletRequest和HttpServletResponse接口中定义）。因此，你需要将ServletRequest和ServletResponse对象强制转换（强制类型转换，或称为“向下转型”）为HttpServletRequest和HttpServletResponse，以便能够访问和使用这些HTTP特定的方法和属性。\n通过获取了访问的路径，判断是否需要进行拦截或者放行。\n利用request.getRequestURI();获取到请求的uri，定义一些不需要处理的路径。如果路径需要进行处理，那么就需要判断用户是否登录了，判断request.getSession().getAttribute(\u0026ldquo;employee\u0026rdquo;) != null，看session中是否有\u0026quot;employee\u0026quot;的属性，因为当时登录的时候，如果成功登录了的话，已经将相应的信息存入了session当中了，request.getSession().setAttribute(\u0026ldquo;employee\u0026rdquo;,emp.getId());\n如果成功登录了的话利用filterChain.doFilter(request,response);将请求放行。退出登录的时候会request.getSession().removeAttribute(\u0026ldquo;employee\u0026rdquo;);。\n如果没有登录就会返回response.getWriter().write(JSON.toJSONString(R.error(\u0026ldquo;NOTLOGIN\u0026rdquo;)));。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 /** * 检查用户是否已经完成登录 */ @WebFilter(filterName = \u0026#34;loginCheckFilter\u0026#34;,urlPatterns = \u0026#34;/*\u0026#34;) @Slf4j public class LoginCheckFilter implements Filter{ //路径匹配器，支持通配符 public static final AntPathMatcher PATH_MATCHER = new AntPathMatcher(); @Override public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException { HttpServletRequest request = (HttpServletRequest) servletRequest; HttpServletResponse response = (HttpServletResponse) servletResponse; //1、获取本次请求的URI String requestURI = request.getRequestURI();// /backend/index.html log.info(\u0026#34;拦截到请求：{}\u0026#34;,requestURI); //定义不需要处理的请求路径 String[] urls = new String[]{ \u0026#34;/employee/login\u0026#34;, \u0026#34;/employee/logout\u0026#34;, \u0026#34;/backend/**\u0026#34;, \u0026#34;/front/**\u0026#34;, \u0026#34;/common/**\u0026#34;, \u0026#34;/user/sendMsg\u0026#34;, \u0026#34;/user/login\u0026#34; }; //2、判断本次请求是否需要处理 boolean check = check(urls, requestURI); //3、如果不需要处理，则直接放行 if(check){ log.info(\u0026#34;本次请求{}不需要处理\u0026#34;,requestURI); filterChain.doFilter(request,response); return; } //4-1、判断登录状态，如果已登录，则直接放行 if(request.getSession().getAttribute(\u0026#34;employee\u0026#34;) != null){ log.info(\u0026#34;用户已登录，用户id为：{}\u0026#34;,request.getSession().getAttribute(\u0026#34;employee\u0026#34;)); Long empId = (Long) request.getSession().getAttribute(\u0026#34;employee\u0026#34;); BaseContext.setCurrentId(empId); filterChain.doFilter(request,response); return; } //4-2、判断登录状态，如果已登录，则直接放行 if(request.getSession().getAttribute(\u0026#34;user\u0026#34;) != null){ log.info(\u0026#34;用户已登录，用户id为：{}\u0026#34;,request.getSession().getAttribute(\u0026#34;user\u0026#34;)); Long userId = (Long) request.getSession().getAttribute(\u0026#34;user\u0026#34;); BaseContext.setCurrentId(userId); filterChain.doFilter(request,response); return; } log.info(\u0026#34;用户未登录\u0026#34;); //5、如果未登录则返回未登录结果，通过输出流方式向客户端页面响应数据 response.getWriter().write(JSON.toJSONString(R.error(\u0026#34;NOTLOGIN\u0026#34;))); return; } /** * 路径匹配，检查本次请求是否需要放行 * @param urls * @param requestURI * @return */ public boolean check(String[] urls,String requestURI){ for (String url : urls) { boolean match = PATH_MATCHER.match(url, requestURI); if(match){ return true; } } return false; } } AntPathMatcher AntPathMatcher 是 Spring 框架中用于路径匹配的一个工具类，它基于 Apache Ant 的路径模式，提供了一套强大的路径匹配机制。以下是 AntPathMatcher 的主要使用方法和场景：\n使用方法\n创建 AntPathMatcher 对象 首先，你需要创建一个 AntPathMatcher 对象：\n1 2 3 java复制代码 AntPathMatcher matcher = new AntPathMatcher(); 路径匹配 使用 match(String pattern, String path) 方法来检查一个路径是否与指定的模式相匹配：\n1 2 3 java复制代码 boolean isMatch = matcher.match(pattern, path); 其中 pattern 是一个包含 Ant 风格匹配模式的字符串，path 是要匹配的路径字符串。\n提取路径变量 如果你使用了路径变量（如 /user/{id}/info），你可以使用 extractPathWithinPattern(String pattern, String path) 或 extractUriTemplateVariables(String pattern, String path) 方法来提取这些变量：\n1 2 String variable = matcher.extractPathWithinPattern(pattern, path); // 提取路径片段，不包括变量名 Map\u0026lt;String, String\u0026gt; variables = matcher.extractUriTemplateVariables(pattern, path); // 提取路径中的变量并放入 Map 使用场景\nURL 映射 在 Spring MVC 中，AntPathMatcher 常用于定义 URL 映射规则。例如，你可以使用 @GetMapping(\u0026quot;/users/{id}\u0026quot;) 来匹配 /users/123 这样的 URL，其中 {id} 是一个路径变量。 安全控制 在安全控制场景中，你可能需要过滤掉某些请求 URL。使用 AntPathMatcher，你可以轻松定义需要过滤的模式，并检查请求 URL 是否与之匹配。 路由和转发 在 API 网关或路由服务中，AntPathMatcher 可以用于匹配传入的请求 URL，并根据匹配结果决定将其路由到哪个后端服务。 日志记录 你可以使用 AntPathMatcher 来过滤出不需要记录日志的请求 URL，或者为不同类型的请求 URL 设置不同的日志级别。 文件访问控制 如果你需要基于路径模式来控制对文件的访问权限，AntPathMatcher 可以帮助你实现这一功能。 特性\n通配符：AntPathMatcher 支持两种通配符：? 表示任意一个字符，* 表示零个或多个字符。 变量绑定：你可以在模式中使用 {variableName} 来定义路径变量，并使用 extractUriTemplateVariables 方法提取这些变量。 多重映射：你可以定义一个包含多个模式的数组，并使用 AntPathMatcher 一次性检查多个模式是否与给定路径匹配。 总结\nAntPathMatcher 是一个功能强大的路径匹配工具，它基于 Apache Ant 的路径模式，提供了灵活且易于使用的路径匹配机制。在 Spring 框架和其他 Java Web 应用程序中，它被广泛用于 URL 映射、安全控制、路由转发等场景。\nThreadLocal 使用了一个工具类对它进行了封装，使其能更方便使用。此处用它的作用就是可以做到自动填充当前登录的用户名，因为此时无法获取到HttpServletRequest或者session，因此就并没有很好的方法获取，就使用ThreadLocal来实现。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public class BaseContext { private static ThreadLocal\u0026lt;Long\u0026gt; threadLocal = new ThreadLocal\u0026lt;\u0026gt;(); /** * 设置值 * @param id */ public static void setCurrentId(Long id){ threadLocal.set(id); } /** * 获取值 * @return */ public static Long getCurrentId(){ return threadLocal.get(); } } 1 2 3 4 5 6 7 8 9 if(request.getSession().getAttribute(\u0026#34;employee\u0026#34;) != null){ log.info(\u0026#34;用户已登录，用户id为：{}\u0026#34;,request.getSession().getAttribute(\u0026#34;employee\u0026#34;)); Long empId = (Long) request.getSession().getAttribute(\u0026#34;employee\u0026#34;); BaseContext.setCurrentId(empId); filterChain.doFilter(request,response); return; } ThreadLocal的详细介绍和使用\n一、ThreadLocal的详细介绍\nThreadLocal是Java并发包（java.util.concurrent）中提供的一个类，用于解决多线程环境下变量共享所带来的线程安全问题。其主要作用是在多线程环境下为每个线程提供一个独立的变量副本，使得每个线程在访问ThreadLocal时获取到的都是自己的私有变量，而不是共享的同一个变量。这样，ThreadLocal能够隔离线程间的数据共享，提供线程级别的数据存储。\n定义与特点 ThreadLocal类提供了一种线程局部变量的机制，使得每个线程都可以独立地改变自己的变量副本，而不会影响到其他线程的变量副本。 每个线程在访问ThreadLocal变量时，都会获取到属于自己的、独立的变量副本。 应用场景 线程上下文信息传递：例如在web应用中，服务器接收到请求后，需要在不同的过滤器、处理器链路中传递用户会话信息，此时可以将这些信息存放在ThreadLocal中。 避免同步开销：对于那些只需要在单个线程内保持状态，不需要线程间共享的数据，使用ThreadLocal可以避免使用锁带来的性能损耗。 数据库连接、事务管理：在多线程环境下，每个线程有自己的数据库连接，可以使用ThreadLocal存储当前线程的数据库连接对象，以确保线程安全。 核心方法 set(T value)：设置当前线程的变量副本值。 get()：获取当前线程所对应的变量副本的值，如果此线程从未设置过值，那么返回null或者初始值（如果有的话）。 remove()：删除当前线程保存的变量副本，如果不主动清理，可能会造成内存泄露。 内存泄露问题 当线程结束生命周期后，如果没有显式调用remove()方法，存储在线程本地变量表中的ThreadLocal变量副本不会自动删除，这可能导致它们无法被垃圾回收，尤其是在线程池场景中，如果线程会被复用，这个问题更为突出。 线程安全的误解 虽然ThreadLocal保证了每个线程只能访问自己的变量副本，但是它并不能保证变量副本本身的线程安全性。即如果存放在ThreadLocal中的对象不是线程安全的，多个线程通过各自的ThreadLocal访问相同的非线程安全对象时，还需要采取额外的同步措施。 二、ThreadLocal的使用\n基本用法 创建一个ThreadLocal变量。 在每个线程内部，使用set(T value)方法给当前线程设置一个本地变量的值。 在需要的时候，使用get()方法来获取当前线程关联的本地变量的值。 使用完毕后，调用remove()方法清除当前线程的ThreadLocal变量。 代码示例 以下是一个简单的代码示例，展示了ThreadLocal的基本用法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 import java.lang.ThreadLocal; public class ThreadLocalExample { // 定义一个ThreadLocal变量，这里存储的是String类型 public static final ThreadLocal\u0026lt;String\u0026gt; threadLocal = new ThreadLocal\u0026lt;\u0026gt;(); public static void main(String[] args) { // 创建两个线程并启动 new Thread(() -\u0026gt; { // 设置当前线程的ThreadLocal变量 threadLocal.set(\u0026#34;Thread A\u0026#34;); System.out.println(\u0026#34;In Thread A: \u0026#34; + threadLocal.get()); }).start(); new Thread(() -\u0026gt; { // 设置当前线程的ThreadLocal变量，不影响其他线程 threadLocal.set(\u0026#34;Thread B\u0026#34;); System.out.println(\u0026#34;In Thread B: \u0026#34; + threadLocal.get()); // 清理本线程的ThreadLocal变量 threadLocal.remove(); // 此时尝试获取已经移除的ThreadLocal变量，应该返回null System.out.println(\u0026#34;After remove in Thread B: \u0026#34; + threadLocal.get()); }).start(); } } 在这个示例中，我们创建了一个ThreadLocal\u0026lt;String\u0026gt;类型的静态变量threadLocal。在每个线程内部，我们使用set(String value)方法给当前线程设置了一个本地变量的值。同样在每个线程内部，我们使用get()方法来获取当前线程关联的本地变量的值。注意，每个线程只能获取到自己设置的那个值，相互之间不会干扰。在第二个线程里展示了如何使用remove()方法清除当前线程的ThreadLocal变量。\n注意事项 在使用完ThreadLocal对象后，在finally中调用ThreadLocal对象的remove()方法，以避免内存泄露。 不要过度使用ThreadLocal，以免代码逻辑变得复杂，增加维护难度。 当线程间本来就需要共享数据时，不应该滥用ThreadLocal避免数据交换。 总之，ThreadLocal是一个在多线程环境下非常有用的工具类，它可以帮助我们避免线程安全问题，并提供线程级别的数据存储。但是，在使用时需要注意内存泄露问题和线程安全的误解等风险。\nMybatisP的自动填充功能 有时候有一些数据如果前端并不会传过来，并且后端存入数据库的时候还需要，那么此时就可以使用自动填充功能来实现了。\n例如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 @Data public class SetmealDish implements Serializable { private static final long serialVersionUID = 1L; private Long id; //套餐id private Long setmealId; //菜品id private Long dishId; //菜品名称 （冗余字段） private String name; //菜品原价 private BigDecimal price; //份数 private Integer copies; //排序 private Integer sort; @TableField(fill = FieldFill.INSERT) private LocalDateTime createTime; @TableField(fill = FieldFill.INSERT_UPDATE) private LocalDateTime updateTime; @TableField(fill = FieldFill.INSERT) private Long createUser; @TableField(fill = FieldFill.INSERT_UPDATE) private Long updateUser; //是否删除 private Integer isDeleted; } @TableField 写到需要自动填充的属性上面，并且需要指定fill的属性\n有一下几种类型：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public enum FieldFill { /** * 默认不处理 */ DEFAULT, /** * 插入时填充字段 */ INSERT, /** * 更新时填充字段 */ UPDATE, /** * 插入和更新时填充字段 */ INSERT_UPDATE } MetaObjectHandler 接着还需要对需要对自动填充进行配置，例如插入和更新时候分别怎样进行配置\n1.实现MetaObjectHandler\n2.类上面加@Component注解，将其纳入spring容器管理\n3.重写insertFill和updateFill方法，利用metaObject.setValue()对相应的属性进行赋值。例如：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 @Component @Slf4j public class MyMetaObjecthandler implements MetaObjectHandler { /** * 插入操作，自动填充 * @param metaObject */ @Override public void insertFill(MetaObject metaObject) { log.info(\u0026#34;公共字段自动填充[insert]...\u0026#34;); log.info(metaObject.toString()); metaObject.setValue(\u0026#34;createTime\u0026#34;, LocalDateTime.now()); metaObject.setValue(\u0026#34;updateTime\u0026#34;,LocalDateTime.now()); metaObject.setValue(\u0026#34;createUser\u0026#34;,BaseContext.getCurrentId()); metaObject.setValue(\u0026#34;updateUser\u0026#34;,BaseContext.getCurrentId()); } /** * 更新操作，自动填充 * @param metaObject */ @Override public void updateFill(MetaObject metaObject) { log.info(\u0026#34;公共字段自动填充[update]...\u0026#34;); log.info(metaObject.toString()); long id = Thread.currentThread().getId(); log.info(\u0026#34;线程id为：{}\u0026#34;,id); metaObject.setValue(\u0026#34;updateTime\u0026#34;,LocalDateTime.now()); metaObject.setValue(\u0026#34;updateUser\u0026#34;,BaseContext.getCurrentId()); } } RESTFul风格以及接收请求的方法 RESTFul，即RESTful，是一种面向资源的软件架构风格，它是Representational State Transfer（表示状态转移）的缩写。以下是对RESTful风格的详细介绍：\n一、设计目标\nRESTful风格的设计目标是在分布式系统中实现统一的接口和交互方式，以提高系统的可扩展性、可靠性和可维护性。\n二、核心特点\n资源导向：RESTful架构将整个系统看作一组资源的集合，每个资源都有一个唯一的URI（统一资源标识符）。客户端通过URI来访问资源，服务器通过HTTP方法来操作资源。 统一接口：RESTful架构定义了一组统一的接口，包括HTTP方法（如GET、POST、PUT、DELETE等）、URI和HTTP状态码等。客户端和服务器之间的通信只需要遵循这些接口，就可以实现系统的交互。 无状态：RESTful架构是无状态的，每个请求都是独立的，服务器不需要维护客户端的状态信息。这样可以提高系统的可伸缩性和可靠性。 可缓存性：RESTful架构支持缓存机制，客户端可以通过缓存来提高系统的性能和可靠性。 三、HTTP方法\n在RESTful风格中，常见的HTTP方法包括：\nGET：用于获取资源。 POST：用于创建资源（在某些情况下，也可以用于更新资源）。 PUT：用于更新服务端的资源的全部信息。 DELETE：用于删除服务端的资源。 此外，还有PATCH方法，它用于更新服务端的资源的部分信息。\n四、资源的表现形式\n在RESTful架构中，资源的表现形式通常是XML或HTML。客户端通过操作资源的表现形式来操作资源。\n五、设计原则\n使用名词而不是动词：在定义URI时，应使用名词来表示资源，而不是动词。例如，使用“/users”来表示用户资源，而不是“/getAllUsers”。 GET方法和查询参数不应涉及状态改变：应使用PUT、POST和DELETE方法来改变状态，而不是GET方法。同时，查询参数应仅用于过滤和排序资源，而不应改变资源的状态。 保持URI的简洁和一致性：URI应简洁明了，易于理解和记忆。同时，应保持URI的一致性，以便于客户端正确地访问和操作资源。 使用HTTP头声明序列化格式：在客户端和服务端之间通信时，应使用HTTP头来声明序列化格式，以确保双方都能正确地解析和处理数据。 六、优势\n简化客户端与服务器的交互：通过定义一组统一的接口和交互方式，RESTful风格可以简化客户端与服务器的交互过程，降低通信的复杂性。 提高系统的可扩展性和可靠性：由于RESTful风格是无状态的，每个请求都是独立的，因此可以提高系统的可扩展性和可靠性。同时，支持缓存机制也可以进一步提高系统的性能。 易于实现和维护：RESTful风格基于HTTP协议的各种特性来实现资源的标识、状态的转移、缓存、安全性等功能，因此易于实现和维护。 综上所述，RESTful风格是一种基于HTTP协议的面向资源的软件架构风格，它通过定义一组统一的接口和交互方式，提高了系统的可扩展性、可靠性和可维护性。在实际开发中，应遵循RESTful风格的设计原则和设计规范，以确保系统的稳定性和高效性。\n后端接收数据的方法 Java Web开发中，前端数据可以通过多种方式传输到后端，并且后端会相应地解析这些请求以获取数据。以下是一些常见的数据传输方式以及后端如何接收这些数据的情况：\n1. 通过URL查询参数传输\n方式：前端将数据作为查询参数附加到URL的末尾。\n示例：http://example.com/resource?param1=value1\u0026amp;param2=value2\n接收：在后端，你可以使用@RequestParam注解来接收这些参数。\n1 2 3 4 @GetMapping(\u0026#34;/resource\u0026#34;) public ResponseEntity\u0026lt;?\u0026gt; getResource(@RequestParam String param1, @RequestParam String param2) { // 处理参数 } 2. 通过URL路径变量传输\n方式：前端将数据嵌入到URL的路径中。\n示例：http://example.com/resource/123/name\n接收：在后端，你可以使用@PathVariable注解来接收这些路径变量。\n1 2 3 4 @GetMapping(\u0026#34;/resource/{id}/{name}\u0026#34;) public ResponseEntity\u0026lt;?\u0026gt; getResource(@PathVariable Long id, @PathVariable String name) { // 处理路径变量 } 3. 通过表单数据（POST请求）传输\n方式：前端通过HTML表单或AJAX发送POST请求，数据在请求体中作为表单字段传输。\n接收：在后端，你可以使用@ModelAttribute或@RequestBody（如果数据是JSON或XML格式）来接收这些数据。对于简单的表单数据，@ModelAttribute更常用；对于复杂的JSON或XML数据，@RequestBody更合适。\n1 2 3 4 5 6 7 8 9 10 11 // 使用@ModelAttribute接收简单的表单数据 @PostMapping(\u0026#34;/form\u0026#34;) public ResponseEntity\u0026lt;?\u0026gt; handleFormSubmit(@ModelAttribute FormData formData) { // 处理表单数据 } // 使用@RequestBody接收JSON数据 @PostMapping(\u0026#34;/json\u0026#34;) public ResponseEntity\u0026lt;?\u0026gt; handleJsonSubmit(@RequestBody JsonData jsonData) { // 处理JSON数据 } 4. 通过请求体（非表单数据）传输\n方式：前端发送POST或PUT请求，数据作为请求体的内容（通常是JSON、XML或其他格式）传输。\n接收：在后端，你通常使用@RequestBody注解来接收这些数据，并将其反序列化为Java对象。\n1 2 3 4 @PostMapping(\u0026#34;/data\u0026#34;) public ResponseEntity\u0026lt;?\u0026gt; handleDataSubmit(@RequestBody DataObject dataObject) { // 处理数据对象 } 5. 通过请求头传输\n方式：前端将数据作为HTTP请求头的一部分发送。\n接收：在后端，你可以通过@RequestHeader注解来接收这些请求头。\n1 2 3 4 @GetMapping(\u0026#34;/header\u0026#34;) public ResponseEntity\u0026lt;?\u0026gt; getResourceByHeader(@RequestHeader String customHeader) { // 处理请求头 } 6. 通过文件上传传输\n方式：前端通过HTML表单或AJAX发送文件上传请求，数据作为文件内容传输。\n接收：在后端，你可以使用@RequestParam(\u0026quot;file\u0026quot;) MultipartFile file来接收上传的文件。\n1 2 3 4 @PostMapping(\u0026#34;/upload\u0026#34;) public ResponseEntity\u0026lt;?\u0026gt; handleFileUpload(@RequestParam(\u0026#34;file\u0026#34;) MultipartFile file) { // 处理上传的文件 } 总结\n查询参数：适用于GET请求，数据量少且简单。 路径变量：适用于GET请求，用于标识资源ID或名称等。 表单数据：适用于POST请求，数据作为表单字段传输。 请求体：适用于POST或PUT请求，数据作为请求体内容传输，可以是JSON、XML等格式。 请求头：适用于所有类型的请求，数据作为HTTP请求头的一部分传输。 文件上传：适用于POST请求，数据作为文件内容传输。 根据具体的应用场景和需求，选择合适的数据传输方式和接收方法。\n根据你提供的信息，这里是每种数据传输方式对应的前端请求示例：\n通过URL查询参数传输\n前端请求示例：使用JavaScript的fetch函数或者XMLHttpRequest来发送GET请求，并将查询参数附加到URL的末尾。 示例代码： 1 2 3 4 fetch(\u0026#39;http://example.com/resource?param1=value1\u0026amp;param2=value2\u0026#39;) .then(response =\u0026gt; response.json()) .then(data =\u0026gt; console.log(data)) .catch(error =\u0026gt; console.error(\u0026#39;Error:\u0026#39;, error)); 通过URL路径变量传输\n前端请求示例：使用JavaScript的fetch函数或者XMLHttpRequest来发送GET请求，并将数据嵌入到URL的路径中。 示例代码： 1 2 3 4 fetch(\u0026#39;http://example.com/resource/123/name\u0026#39;) .then(response =\u0026gt; response.json()) .then(data =\u0026gt; console.log(data)) .catch(error =\u0026gt; console.error(\u0026#39;Error:\u0026#39;, error)); 通过表单数据（POST请求）传输\n前端请求示例：使用表单或者AJAX发送POST请求，数据在请求体中作为表单字段传输。 示例代码（使用Fetch API）： 1 2 3 4 5 6 7 8 9 10 11 const formData = new FormData(); formData.append(\u0026#39;param1\u0026#39;, \u0026#39;value1\u0026#39;); formData.append(\u0026#39;param2\u0026#39;, \u0026#39;value2\u0026#39;); fetch(\u0026#39;http://example.com/form\u0026#39;, { method: \u0026#39;POST\u0026#39;, body: formData }) .then(response =\u0026gt; response.json()) .then(data =\u0026gt; console.log(data)) .catch(error =\u0026gt; console.error(\u0026#39;Error:\u0026#39;, error)); 通过请求体（非表单数据）传输\n前端请求示例：发送POST或PUT请求，数据作为请求体的内容（通常是JSON、XML或其他格式）传输。 示例代码（使用Fetch API发送JSON数据）： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 const data = { key1: \u0026#39;value1\u0026#39;, key2: \u0026#39;value2\u0026#39; }; fetch(\u0026#39;http://example.com/data\u0026#39;, { method: \u0026#39;POST\u0026#39;, headers: { \u0026#39;Content-Type\u0026#39;: \u0026#39;application/json\u0026#39;, }, body: JSON.stringify(data), }) .then(response =\u0026gt; response.json()) .then(data =\u0026gt; console.log(data)) .catch(error =\u0026gt; console.error(\u0026#39;Error:\u0026#39;, error)); 通过请求头传输\n前端请求示例：将数据作为HTTP请求头的一部分发送。 示例代码（使用Fetch API）： 1 2 3 4 5 6 7 8 9 fetch(\u0026#39;http://example.com/header\u0026#39;, { method: \u0026#39;GET\u0026#39;, headers: { \u0026#39;Custom-Header\u0026#39;: \u0026#39;value\u0026#39; } }) .then(response =\u0026gt; response.json()) .then(data =\u0026gt; console.log(data)) .catch(error =\u0026gt; console.error(\u0026#39;Error:\u0026#39;, error)); 通过文件上传传输\n前端请求示例：通过HTML表单或AJAX发送文件上传请求，数据作为文件内容传输。 示例代码（使用Fetch API上传文件）： 1 2 3 4 5 6 7 8 9 10 11 const formData = new FormData(); const fileInput = document.querySelector(\u0026#39;input[type=\u0026#34;file\u0026#34;]\u0026#39;); formData.append(\u0026#39;file\u0026#39;, fileInput.files[0]); fetch(\u0026#39;http://example.com/upload\u0026#39;, { method: \u0026#39;POST\u0026#39;, body: formData }) .then(response =\u0026gt; response.json()) .then(data =\u0026gt; console.log(data)) .catch(error =\u0026gt; console.error(\u0026#39;Error:\u0026#39;, error)); 这些示例展示了如何使用JavaScript的Fetch API来发送不同类型的请求。对于HTML表单，你可以直接在表单标签中设置action和method属性，并通过浏览器的原生表单提交功能来发送请求。\nR类 为了方便前后端数据的传输而引出的类，它可以定义一些能够将前端需要的信息响应过去的属性，从而达到方比那传输的目的。\n对此处类的解析。它一个非常好的点就是利用了泛型，可以接收各种类型的变量。\n起初就在类首部定义为class R，好像也可以定义多个泛型。那么就可以去定义泛型数据private T data;接着去方法里运行。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 /** * 通用返回结果，服务端响应的数据最终都会封装成此对象 * @param \u0026lt;T\u0026gt; */ @Data public class R\u0026lt;T\u0026gt; { private Integer code; //编码：1成功，0和其它数字为失败 private String msg; //错误信息 private T data; //数据 private Map map = new HashMap(); //动态数据 public static \u0026lt;T\u0026gt; R\u0026lt;T\u0026gt; success(T object) { R\u0026lt;T\u0026gt; r = new R\u0026lt;T\u0026gt;(); r.data = object; r.code = 1; return r; } public static \u0026lt;T\u0026gt; R\u0026lt;T\u0026gt; error(String msg) { R r = new R(); r.msg = msg; r.code = 0; return r; } public R\u0026lt;T\u0026gt; add(String key, Object value) { this.map.put(key, value); return this; } } 1 2 3 4 5 6 public static \u0026lt;T\u0026gt; R\u0026lt;T\u0026gt; success(T object) { R\u0026lt;T\u0026gt; r = new R\u0026lt;T\u0026gt;(); r.data = object; r.code = 1; return r; } 可以使用的方法例如：\n1 2 3 4 5 public R\u0026lt;String\u0026gt; logout(HttpServletRequest request){ //清理Session中保存的当前登录员工的id request.getSession().removeAttribute(\u0026#34;employee\u0026#34;); return R.success(\u0026#34;退出成功\u0026#34;); } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public R\u0026lt;Employee\u0026gt; login(HttpServletRequest request,@RequestBody Employee employee){ String password = employee.getPassword(); password = DigestUtils.md5DigestAsHex(password.getBytes()); LambdaQueryWrapper\u0026lt;Employee\u0026gt; queryWrapper = new LambdaQueryWrapper\u0026lt;\u0026gt;(); queryWrapper.eq(Employee::getUsername,employee.getUsername()); Employee emp = employeeService.getOne(queryWrapper); if(emp == null){ return R.error(\u0026#34;登录失败\u0026#34;); } if(!emp.getPassword().equals(password)){ return R.error(\u0026#34;登录失败\u0026#34;); } if(emp.getStatus() == 0){ return R.error(\u0026#34;账号已禁用\u0026#34;); } request.getSession().setAttribute(\u0026#34;employee\u0026#34;,emp.getId()); return R.success(emp); } MP的分页插件 为了不很麻烦地手动写sql语句进行分页查询，此处选用配置MP分页插件来方便查询。\n1 2 3 4 5 6 7 8 9 10 @Configuration public class MybatisPlusConfig { @Bean public MybatisPlusInterceptor mybatisPlusInterceptor(){ MybatisPlusInterceptor mybatisPlusInterceptor = new MybatisPlusInterceptor(); mybatisPlusInterceptor.addInnerInterceptor(new PaginationInnerInterceptor()); return mybatisPlusInterceptor; } } 具体的使用\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 @GetMapping(\u0026#34;/page\u0026#34;) public R\u0026lt;Page\u0026gt; page(int page,int pageSize,String name){ log.info(\u0026#34;page = {},pageSize = {},name = {}\u0026#34; ,page,pageSize,name); //构造分页构造器 Page pageInfo = new Page(page,pageSize); //构造条件构造器 LambdaQueryWrapper\u0026lt;Employee\u0026gt; queryWrapper = new LambdaQueryWrapper(); //添加过滤条件 queryWrapper.like(StringUtils.isNotEmpty(name),Employee::getName,name); //添加排序条件 queryWrapper.orderByDesc(Employee::getUpdateTime); //执行查询 employeeService.page(pageInfo,queryWrapper); return R.success(pageInfo); } MyBatis-Plus中，MybatisPlusInterceptor 是一个核心的组件，它允许你插入自定义的拦截器来处理MyBatis的执行操作。当你配置了 MybatisPlusInterceptor 并添加了 PaginationInnerInterceptor 作为其内部拦截器时，这个分页拦截器会在执行查询操作时自动介入，处理分页逻辑。\n即使你没有在代码中显式地“使用”拦截器，只要你按照以下步骤配置了拦截器，它就会在后台自动工作：\n你的代码中确实使用了MyBatis-Plus的分页功能，并且用到了分页插件。让我们逐步分析你的代码，看看分页是如何实现的：\n@GetMapping(\u0026quot;/page\u0026quot;)：这是一个Spring MVC注解，用于将HTTP GET请求映射到page方法上。\npublic R\u0026lt;Page\u0026gt; page(int page, int pageSize, String name) { ... }：这是控制器中的方法，它接受三个参数：当前页码、每页显示的记录数和一个名字搜索条件，并返回一个分页结果。\nlog.info(\u0026quot;page = {},pageSize = {},name = {}\u0026quot;, page, pageSize, name);：这行代码使用SLF4J日志记录请求的分页参数，有助于调试。\nPage pageInfo = new Page(page, pageSize);：这里创建了一个新的Page对象，它是MyBatis-Plus分页功能的载体，包含了分页的请求参数。\nLambdaQueryWrapper\u0026lt;Employee\u0026gt; queryWrapper = new LambdaQueryWrapper\u0026lt;\u0026gt;();：创建了一个用于构建查询条件的LambdaQueryWrapper对象。\nqueryWrapper.like(StringUtils.isNotEmpty(name), Employee::getName, name);：如果name参数不为空，则添加一个模糊匹配条件，用于搜索员工名称。\nqueryWrapper.orderByDesc(Employee::getUpdateTime);：设置查询结果按员工更新时间降序排序。\nemployeeService.page(pageInfo, queryWrapper);：这是关键的一步，它调用了employeeService的page方法。在这个方法内部，MyBatis-Plus会利用你之前配置的MybatisPlusInterceptor和其中的PaginationInnerInterceptor来处理分页逻辑。这个方法会返回一个IPage类型的结果，它包含了分页查询的结果以及分页信息（如总记录数、总页数等）。\nreturn R.success(pageInfo);：最后，方法返回一个成功的响应，其中包含了分页信息和查询结果。\n你的代码中没有直接引用MybatisPlusInterceptor或PaginationInnerInterceptor，是因为这些组件是在Spring Boot的配置类中配置的，通常是在application.yml或application.properties文件中配置，或者如前所述，在Java配置类中通过@Bean方法配置。一旦配置完成，这些拦截器就会自动在MyBatis-Plus执行查询时起作用。\n因此，即使你的代码中没有显式地“使用”分页插件，只要你按照前面的步骤配置了MybatisPlusInterceptor和PaginationInnerInterceptor，它们就会在后台自动工作，为你的分页查询提供支持。这就是为什么你的代码能够实现分页功能的原因。\n拦截器（Interceptor）与过滤器（Filter）的区别：\n过滤器（Filter）： 工作在Web应用服务器的Servlet层面，可以在请求到达Servlet之前或响应返回给客户端之前进行拦截处理。 主要用于处理Web请求的预处理和后处理，如日志记录、权限检查、请求内容修改等。 通常用于处理HTTP请求和响应。 拦截器（Interceptor）： 工作在框架层面，如Spring或MyBatis，可以在业务逻辑执行前后进行拦截处理。 主要用于处理特定的业务逻辑，如事务管理、日志记录、性能监控等。 可以更细粒度地控制业务逻辑的执行流程。 在MyBatis-Plus中，MybatisPlusInterceptor 及其内部拦截器（如 PaginationInnerInterceptor）通常用于处理分页查询。下面我将给出两个案例，一个使用 PaginationInnerInterceptor 进行分页查询，另一个不使用它。\n使用 PaginationInnerInterceptor 的案例：\n在这个案例中，我们使用 MybatisPlusInterceptor 和 PaginationInnerInterceptor 来实现分页查询。首先，我们需要配置 MybatisPlusConfig 类，如你之前所示：\n1 2 3 4 5 6 7 8 9 10 @Configuration public class MybatisPlusConfig { @Bean public MybatisPlusInterceptor mybatisPlusInterceptor(){ MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor(); interceptor.addInnerInterceptor(new PaginationInnerInterceptor()); return interceptor; } } 然后，我们可以在服务层（Service）使用 Page 对象来执行分页查询：\n1 2 3 4 5 6 7 8 9 10 11 12 @Service public class EmployeeService { @Autowired private EmployeeMapper employeeMapper; public IPage\u0026lt;Employee\u0026gt; getEmployeesByPage(int currentPage, int pageSize) { Page\u0026lt;Employee\u0026gt; page = new Page\u0026lt;\u0026gt;(currentPage, pageSize); IPage\u0026lt;Employee\u0026gt; employeePage = employeeMapper.selectPage(page, null); return employeePage; } } 在控制器层（Controller），我们可以接收分页参数并调用服务层的方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 @RestController @RequestMapping(\u0026#34;/employees\u0026#34;) public class EmployeeController { @Autowired private EmployeeService employeeService; @GetMapping(\u0026#34;/page\u0026#34;) public R\u0026lt;IPage\u0026lt;Employee\u0026gt;\u0026gt; getEmployeesByPage(@RequestParam int page, @RequestParam int size) { IPage\u0026lt;Employee\u0026gt; employeePage = employeeService.getEmployeesByPage(page, size); return R.ok().data(\u0026#34;items\u0026#34;, employeePage.getRecords()).extra(\u0026#34;total\u0026#34;, employeePage.getTotal()); } } 不使用 PaginationInnerInterceptor 的案例：\n如果我们不使用 PaginationInnerInterceptor，那么我们需要在每次执行分页查询时手动编写分页逻辑。这通常涉及到编写特定的SQL语句来实现分页，或者在应用层手动处理分页逻辑。\n例如，不使用分页拦截器时，我们可能需要在Mapper接口中定义一个自定义的分页查询方法，并在XML文件中编写相应的SQL：\n1 2 3 4 // EmployeeMapper.java public interface EmployeeMapper extends BaseMapper\u0026lt;Employee\u0026gt; { IPage\u0026lt;Employee\u0026gt; selectPageWithCustomSql(IPage\u0026lt;?\u0026gt; page, @Param(\u0026#34;name\u0026#34;) String name); } 在XML文件中：\n1 2 3 4 5 6 \u0026lt;!-- EmployeeMapper.xml --\u0026gt; \u0026lt;select id=\u0026#34;selectPageWithCustomSql\u0026#34; resultType=\u0026#34;Employee\u0026#34;\u0026gt; SELECT * FROM employee WHERE name LIKE CONCAT(\u0026#39;%\u0026#39;, #{name}, \u0026#39;%\u0026#39;) LIMIT #{page.offset}, #{page.size} \u0026lt;/select\u0026gt; 在服务层，我们调用这个自定义的分页查询方法：\n1 2 3 4 5 6 7 8 9 10 11 12 @Service public class EmployeeService { @Autowired private EmployeeMapper employeeMapper; public IPage\u0026lt;Employee\u0026gt; getEmployeesByPage(int currentPage, int pageSize, String name) { Page\u0026lt;Employee\u0026gt; page = new Page\u0026lt;\u0026gt;(currentPage, pageSize); IPage\u0026lt;Employee\u0026gt; employeePage = employeeMapper.selectPageWithCustomSql(page, name); return employeePage; } } 在控制器层，我们同样接收分页参数并调用服务层的方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 @RestController @RequestMapping(\u0026#34;/employees\u0026#34;) public class EmployeeController { @Autowired private EmployeeService employeeService; @GetMapping(\u0026#34;/page\u0026#34;) public R\u0026lt;IPage\u0026lt;Employee\u0026gt;\u0026gt; getEmployeesByPage(@RequestParam int page, @RequestParam int size, @RequestParam String name) { IPage\u0026lt;Employee\u0026gt; employeePage = employeeService.getEmployeesByPage(page, size, name); return R.ok().data(\u0026#34;items\u0026#34;, employeePage.getRecords()).extra(\u0026#34;total\u0026#34;, employeePage.getTotal()); } } 在这个案例中，我们没有使用 PaginationInnerInterceptor，因此需要在每次查询时手动处理分页逻辑，这增加了代码的复杂性，并且降低了代码的可维护性。使用 PaginationInnerInterceptor 可以简化这个过程，使得分页查询更加方便和高效。\nMyBatis-Plus 提供了多种内置拦截器，除了分页拦截器 PaginationInnerInterceptor 外，还包括但不限于以下几种：\n多租户插件 TenantLineInnerInterceptor：用于实现多租户场景下的数据隔离。通过这个拦截器，可以根据租户的ID或其他标识来动态修改SQL，以确保每个租户只能访问到自己的数据。这对于SaaS应用尤其有用。\n动态表名插件 DynamicTableNameInnerInterceptor：允许在运行时动态改变表名。这对于需要根据不同条件访问不同数据库表的场景非常有用。\n乐观锁插件 OptimisticLockerInnerInterceptor：提供了乐观锁机制，用于处理并发更新数据时可能出现的冲突。通过版本号或其他机制来确保数据的一致性。\nSQL性能规范插件 IllegalSQLInnerInterceptor：用于检查和防止执行可能影响数据库性能的SQL语句，如没有WHERE子句的UPDATE或DELETE语句。\n防止全表更新与删除插件 BlockAttackInnerInterceptor：用于防止执行可能导致全表扫描或锁定的有害SQL语句，如不带WHERE子句的UPDATE或DELETE操作。\n数据权限控制拦截器：可以实现基于用户权限的动态SQL修改，以控制不同用户可以访问的数据范围。这通常通过自定义拦截器实现，根据当前用户的角色或权限来修改SQL语句。\n自定义拦截器：除了内置的拦截器，MyBatis-Plus 也支持开发者根据具体需求自定义拦截器。自定义拦截器可以实现各种功能，如添加租户隔离、审计日志记录、SQL优化等。\n这些拦截器可以通过配置类 MybatisPlusConfig 进行配置，如下所示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 @Configuration public class MybatisPlusConfig { @Bean public MybatisPlusInterceptor mybatisPlusInterceptor(){ MybatisPlusInterceptor interceptor = new MybatisPlusInterceptor(); interceptor.addInnerInterceptor(new PaginationInnerInterceptor()); // 添加其他拦截器 interceptor.addInnerInterceptor(new TenantLineInnerInterceptor()); interceptor.addInnerInterceptor(new DynamicTableNameInnerInterceptor()); // ...添加更多拦截器 return interceptor; } } 那么实际开发中，根据项目的具体需求选择合适的拦截器进行配置，可以有效地增强MyBatis-Plus的功能，提高开发效率和应用性能。\nPage类 在MyBatis-Plus中，Page 类是一个非常重要的类，它用于承载分页查询的请求参数以及返回的分页结果。当你执行分页查询并获得结果时，Page 对象包含了以下主要内容：\n当前页码（Current Page）：\n表示请求的页码，即用户请求查看的是哪一页的数据。 每页数量（Page Size）：\n表示每一页显示的记录数。 总记录数（Total Count）：\n表示查询条件下的总记录数。这个数字是通过对整个数据集进行计数获得的，对于分页查询来说，这个数字是非常重要的，因为它决定了可以分多少页。 总页数（Total Pages）：\n根据总记录数和每页数量计算出的总页数。如果总记录数不能被每页数量整除，总页数会向上取整。 记录列表（Records）：\n包含了当前页的记录列表。这是执行分页查询后，数据库返回的当前页的数据记录。 是否第一页（Is First Page）：\n一个布尔值，表示当前页是否是第一页。 是否最后一页（Is Last Page）：\n一个布尔值，表示当前页是否是最后一页。 是否有前一页（Has Previous Page）：\n一个布尔值，表示当前页是否有前一页。 是否有下一页（Has Next Page）：\n一个布尔值，表示当前页是否有下一页。 分页参数（Page Parameters）：\n可能包含一些额外的分页参数，如排序信息等。 当你使用 employeeService.page(pageInfo, queryWrapper) 方法执行分页查询时，MyBatis-Plus框架会在内部处理分页逻辑，并填充 Page 对象的上述属性。最终，你可以通过返回的 Page 对象获取到所有这些分页信息，以及当前页的数据记录。\n在实际的Web应用中，这些信息通常被用来构建分页导航，以及展示当前页的数据。例如，你可以使用总页数来生成分页控件中的页码链接，使用记录列表来显示当前页的数据。\n对应前端代码 在前端使用Vue.js处理分页数据，你可以创建一个Vue组件来发送请求、处理响应并展示数据。以下是使用Vue 2.x版本的示例：\n1. 创建Vue组件\n首先，确保你已经在你的项目中安装了Axios，这是一个用于发送HTTP请求的库。如果还没有安装，可以通过以下命令安装：\n1 npm install axios 然后，创建一个名为EmployeePage.vue的Vue组件：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 \u0026lt;template\u0026gt; \u0026lt;div\u0026gt; \u0026lt;h1\u0026gt;Employee List\u0026lt;/h1\u0026gt; \u0026lt;input v-model=\u0026#34;searchName\u0026#34; placeholder=\u0026#34;Search by name\u0026#34; @input=\u0026#34;fetchPageData\u0026#34; /\u0026gt; \u0026lt;table\u0026gt; \u0026lt;thead\u0026gt; \u0026lt;tr\u0026gt; \u0026lt;th\u0026gt;Name\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;Age\u0026lt;/th\u0026gt; \u0026lt;th\u0026gt;Update Time\u0026lt;/th\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/thead\u0026gt; \u0026lt;tbody\u0026gt; \u0026lt;tr v-for=\u0026#34;employee in pageInfo.records\u0026#34; :key=\u0026#34;employee.id\u0026#34;\u0026gt; \u0026lt;td\u0026gt;{{ employee.name }}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;{{ employee.age }}\u0026lt;/td\u0026gt; \u0026lt;td\u0026gt;{{ formatDate(employee.updateTime) }}\u0026lt;/td\u0026gt; \u0026lt;/tr\u0026gt; \u0026lt;/tbody\u0026gt; \u0026lt;/table\u0026gt; \u0026lt;div class=\u0026#34;pagination\u0026#34;\u0026gt; \u0026lt;button v-if=\u0026#34;pageInfo.current \u0026gt; 1\u0026#34; @click=\u0026#34;fetchPageData(pageInfo.current - 1, pageInfo.size)\u0026#34; \u0026gt; Previous \u0026lt;/button\u0026gt; \u0026lt;span\u0026gt;{{ pageInfo.current }}\u0026lt;/span\u0026gt; of \u0026lt;span\u0026gt;{{ pageInfo.pages }}\u0026lt;/span\u0026gt; \u0026lt;button v-if=\u0026#34;pageInfo.current \u0026lt; pageInfo.pages\u0026#34; @click=\u0026#34;fetchPageData(pageInfo.current + 1, pageInfo.size)\u0026#34; \u0026gt; Next \u0026lt;/button\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import axios from \u0026#39;axios\u0026#39;; export default { data() { return { pageInfo: { records: [] }, searchName: \u0026#39;\u0026#39;, currentPage: 1, pageSize: 10 }; }, methods: { async fetchPageData(page, size) { try { const response = await axios.get(`/page`, { params: { page, size, name: this.searchName } }); this.pageInfo = response.data; } catch (error) { console.error(\u0026#39;Error fetching page data:\u0026#39;, error); } }, formatDate(dateString) { const date = new Date(dateString); return date.toLocaleDateString(); } }, created() { this.fetchPageData(this.currentPage, this.pageSize); } }; \u0026lt;/script\u0026gt; \u0026lt;style\u0026gt; table { width: 100%; border-collapse: collapse; } th, td { border: 1px solid #ddd; padding: 8px; text-align: left; } .pagination { margin-top: 20px; } \u0026lt;/style\u0026gt; 2. 注册和使用组件\n确保在你的Vue应用中注册了EmployeePage.vue组件，然后在父组件或App.vue中使用它：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;template\u0026gt; \u0026lt;div id=\u0026#34;app\u0026#34;\u0026gt; \u0026lt;employee-page\u0026gt;\u0026lt;/employee-page\u0026gt; \u0026lt;/div\u0026gt; \u0026lt;/template\u0026gt; \u0026lt;script\u0026gt; import EmployeePage from \u0026#39;./components/EmployeePage.vue\u0026#39;; export default { name: \u0026#39;App\u0026#39;, components: { EmployeePage } }; \u0026lt;/script\u0026gt; 3. 运行你的Vue应用\n确保你的Vue应用正在运行，并且后端服务也已经启动。然后，在浏览器中打开你的Vue应用，你应该能够看到员工列表，并能够通过分页控件浏览不同的页面。\n这个Vue组件使用了组合式API来处理数据获取和分页逻辑。它在组件创建时（created生命周期钩子）发送一个初始请求，然后根据用户的输入和分页按钮点击来更新数据。日期格式化函数formatDate用于将日期字符串转换为更易读的格式。\n那么M的分页插件呢 配置JacksonObjectMapper对象映射器 将它配置好过后还需要进行纳入spring容器管理，等用到的时候会默认自动调用。\n可以从前面笔记地WebMvcConfig里面看\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 /** * 对象映射器:基于jackson将Java对象转为json，或者将json转为Java对象 * 将JSON解析为Java对象的过程称为 [从JSON反序列化Java对象] * 从Java对象生成JSON的过程称为 [序列化Java对象到JSON] */ public class JacksonObjectMapper extends ObjectMapper { public static final String DEFAULT_DATE_FORMAT = \u0026#34;yyyy-MM-dd\u0026#34;; public static final String DEFAULT_DATE_TIME_FORMAT = \u0026#34;yyyy-MM-dd HH:mm:ss\u0026#34;; public static final String DEFAULT_TIME_FORMAT = \u0026#34;HH:mm:ss\u0026#34;; public JacksonObjectMapper() { super(); //收到未知属性时不报异常 this.configure(FAIL_ON_UNKNOWN_PROPERTIES, false); //反序列化时，属性不存在的兼容处理 this.getDeserializationConfig().withoutFeatures(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES); SimpleModule simpleModule = new SimpleModule() .addDeserializer(LocalDateTime.class, new LocalDateTimeDeserializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT))) .addDeserializer(LocalDate.class, new LocalDateDeserializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT))) .addDeserializer(LocalTime.class, new LocalTimeDeserializer(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT))) .addSerializer(BigInteger.class, ToStringSerializer.instance) .addSerializer(Long.class, ToStringSerializer.instance) .addSerializer(LocalDateTime.class, new LocalDateTimeSerializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_TIME_FORMAT))) .addSerializer(LocalDate.class, new LocalDateSerializer(DateTimeFormatter.ofPattern(DEFAULT_DATE_FORMAT))) .addSerializer(LocalTime.class, new LocalTimeSerializer(DateTimeFormatter.ofPattern(DEFAULT_TIME_FORMAT))); //注册功能模块 例如，可以添加自定义序列化器和反序列化器 this.registerModule(simpleModule); } } 1 2 3 4 5 6 7 8 9 10 @Override protected void extendMessageConverters(List\u0026lt;HttpMessageConverter\u0026lt;?\u0026gt;\u0026gt; converters) { log.info(\u0026#34;扩展消息转换器...\u0026#34;); //创建消息转换器对象 MappingJackson2HttpMessageConverter messageConverter = new MappingJackson2HttpMessageConverter(); //设置对象转换器，底层使用Jackson将Java对象转为json messageConverter.setObjectMapper(new JacksonObjectMapper()); //将上面的消息转换器对象追加到mvc框架的转换器集合中 converters.add(0,messageConverter); } 这段代码定义了一个名为 JacksonObjectMapper 的类，它继承自 ObjectMapper 类。ObjectMapper 是 Jackson 库中的核心类，用于将 Java 对象序列化成 JSON 格式的字符串，以及将 JSON 字符串反序列化成 Java 对象。下面是代码中每个部分的详细解释：\n自定义日期时间格式：\nDEFAULT_DATE_FORMAT、DEFAULT_DATE_TIME_FORMAT 和 DEFAULT_TIME_FORMAT 是定义的日期和时间格式字符串，它们分别对应不同的日期时间组件（如日期、日期时间、时间）。 配置 ObjectMapper：\nthis.configure(FAIL_ON_UNKNOWN_PROPERTIES, false); 这行代码配置 ObjectMapper，在反序列化时遇到 JSON 中的未知属性不抛出异常。这在处理 JSON 数据时非常有用，特别是当 JSON 数据包含一些 Java 对象中不存在的属性时。 反序列化配置：\nthis.getDeserializationConfig().withoutFeatures(DeserializationFeature.FAIL_ON_UNKNOWN_PROPERTIES); 这行代码同样用于在反序列化时忽略未知属性，这是另一种配置方式，确保配置被正确应用。 自定义序列化和反序列化器：\nSimpleModule 是 Jackson 库中的一个类，用于注册自定义的序列化器和反序列化器。 addDeserializer 方法用于添加自定义的反序列化器，这里为 LocalDateTime、LocalDate 和 LocalTime 添加了对应的反序列化器，它们使用预定义的格式来解析日期和时间。 addSerializer 方法用于添加自定义的序列化器，这里为 BigInteger、Long、LocalDateTime、LocalDate 和 LocalTime 添加了对应的序列化器，它们将这些类型的值转换为指定格式的字符串。 注册模块：\nthis.registerModule(simpleModule); 这行代码将配置好的 SimpleModule 注册到 ObjectMapper 实例中，使其生效。 为什么需要这样处理，Java程序自带的不行吗？\nJava 自带的序列化机制（如 Serializable 接口）和 Jackson 库做的事情是不同的：\nJava 序列化：Java 通过实现 Serializable 接口提供了一种序列化机制，但它通常用于将整个对象图转换为字节流，以便可以将其持久保存到磁盘或通过网络发送。这种序列化是二进制形式的，不是人类可读的，且不如 JSON 灵活和通用。\nJackson 序列化：Jackson 库提供的序列化机制是将 Java 对象转换为 JSON 格式的字符串。JSON 是一种轻量级的数据交换格式，易于人阅读和编写，同时也易于机器解析和生成。JSON 在 Web 开发中被广泛使用，特别是在前后端分离的架构中。\n此外，Jackson 提供了灵活的配置和扩展机制，允许开发者自定义序列化和反序列化的行为，以满足特定的业务需求。例如，你可以自定义日期时间的格式，处理一些特殊的数据类型（如 BigInteger），或者在序列化和反序列化时执行额外的逻辑。\n因此，虽然 Java 提供了序列化机制，但在需要处理 JSON 数据或需要更灵活的序列化配置时，使用 Jackson 库是更合适的选择。\n全局异常处理器 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 /** * 全局异常处理 */ @ControllerAdvice(annotations = {RestController.class, Controller.class}) @ResponseBody @Slf4j public class GlobalExceptionHandler { /** * 异常处理方法 * @return */ @ExceptionHandler(SQLIntegrityConstraintViolationException.class) public R\u0026lt;String\u0026gt; exceptionHandler(SQLIntegrityConstraintViolationException ex){ log.error(ex.getMessage()); if(ex.getMessage().contains(\u0026#34;Duplicate entry\u0026#34;)){ String[] split = ex.getMessage().split(\u0026#34; \u0026#34;); String msg = split[2] + \u0026#34;已存在\u0026#34;; return R.error(msg); } return R.error(\u0026#34;未知错误\u0026#34;); } /** * 异常处理方法 * @return */ @ExceptionHandler(CustomException.class) public R\u0026lt;String\u0026gt; exceptionHandler(CustomException ex){ log.error(ex.getMessage()); return R.error(ex.getMessage()); } } 这段代码定义了一个名为 GlobalExceptionHandler 的类，它的作用是全局异常处理。这意味着，无论你的Spring应用程序中的哪个部分抛出了异常，只要这个异常是 GlobalExceptionHandler 中定义的方法可以处理的类型，那么这个异常就会被这些方法捕获并统一处理。下面我会逐行解释这段代码：\n@ControllerAdvice 注解：\n这个注解用于定义一个全局的控制器增强器（例如异常处理、数据预处理等），可以被加到任何Spring MVC的控制器上。 annotations = {RestController.class, Controller.class} 参数表示这个增强器会应用到所有标记了 @RestController 或 @Controller 注解的控制器上。 @ResponseBody 注解：\n这个注解表示该类中的所有方法的返回值都将直接作为HTTP响应的正文返回。由于这个注解加在了类上，所以这个类中的所有方法都会自动应用 @ResponseBody 的效果。 @Slf4j 注解：\n这是一个由Lombok库提供的注解，用于自动为类生成日志对象（通常是 private static final Logger log = LoggerFactory.getLogger(Class.class);）。 类定义 public class GlobalExceptionHandler：\n定义了一个公共类 GlobalExceptionHandler。 @ExceptionHandler(SQLIntegrityConstraintViolationException.class) 注解：\n这个注解表示下面的方法将处理 SQLIntegrityConstraintViolationException 类型的异常。 第一个 exceptionHandler 方法：\npublic R\u0026lt;String\u0026gt; exceptionHandler(SQLIntegrityConstraintViolationException ex)： 这个方法接受一个 SQLIntegrityConstraintViolationException 类型的参数 ex，表示它会处理这个类型的异常。 log.error(ex.getMessage());： 使用日志记录器记录异常信息。 if(ex.getMessage().contains(\u0026quot;Duplicate entry\u0026quot;))： 检查异常消息中是否包含 \u0026ldquo;Duplicate entry\u0026rdquo; 字符串。 String msg = split[2] + \u0026quot;已存在\u0026quot;;： 如果包含，则从异常消息中提取出错的数据名称，并拼接上 \u0026ldquo;已存在\u0026rdquo; 字符串，形成新的异常消息。 return R.error(msg);： 返回一个错误响应 R.error(msg)，其中 R 是一个通用响应类，用于封装响应数据。 return R.error(\u0026quot;未知错误\u0026quot;);： 如果异常消息不包含 \u0026ldquo;Duplicate entry\u0026rdquo;，则返回一个通用的错误消息。 第二个 exceptionHandler 方法：\n@ExceptionHandler(CustomException.class)： 这个注解表示下面的方法将处理 CustomException 类型的异常。 public R\u0026lt;String\u0026gt; exceptionHandler(CustomException ex)： 这个方法接受一个 CustomException 类型的参数 ex。 log.error(ex.getMessage());： 记录异常信息。 return R.error(ex.getMessage());： 返回一个错误响应，消息内容为异常 ex 的消息。 总结来说，GlobalExceptionHandler 类是一个全局异常处理器，它捕获并处理特定类型的异常，然后返回统一的错误响应。这样做的好处是，你可以在一个地方集中处理异常，而不是在每个控制器方法中单独处理，这有助于保持代码的整洁和一致性。\n在Java中，确实不能在同一个类中有多个具有相同方法名和参数列表的方法，这被称为方法的重载（Method Overloading）。然而，你提到的GlobalExceptionHandler类中的两个exceptionHandler方法并不是重载，因为它们接受的参数类型不同。\n第一个exceptionHandler方法接受的参数是SQLIntegrityConstraintViolationException类型：\n1 2 3 public R\u0026lt;String\u0026gt; exceptionHandler(SQLIntegrityConstraintViolationException ex){ // ... } 第二个exceptionHandler方法接受的参数是CustomException类型：\n1 2 3 public R\u0026lt;String\u0026gt; exceptionHandler(CustomException ex){ // ... } 由于这两个方法的参数类型不同，它们并不违反Java的重载规则。Java的方法重载是根据方法名和参数列表（包括参数的数量和类型）来区分的。只要参数列表不同，即使方法名相同，它们也是两个完全不同的方法。\n在GlobalExceptionHandler类中，每个exceptionHandler方法都通过@ExceptionHandler注解指定了它所处理的异常类型。当Spring MVC框架遇到相应的异常时，它会调用对应的处理方法。这种方法的组织方式使得异常处理更加模块化和清晰，并且每个方法都可以有自己独特的逻辑来处理特定类型的异常。\n自定义业务异常类 1 2 3 4 5 6 7 8 /** * 自定义业务异常类 */ public class CustomException extends RuntimeException { public CustomException(String message){ super(message); } } 这段代码定义了一个名为 CustomException 的自定义异常类，它继承自 Java 的 RuntimeException 类。下面是对这个类的详细解释：\npublic class CustomException：\n这是一个新的公共类的声明，类名为 CustomException。 extends RuntimeException：\nCustomException 继承自 Java 的 RuntimeException 类。RuntimeException 是一个非受查异常（unchecked exception），意味着编译器不会强制你捕获或抛出这个异常。它通常用于表示程序运行时的错误，比如数组越界、空指针异常等。 public CustomException(String message)：\n这是 CustomException 类的构造器（constructor），它接受一个字符串类型的参数 message。这个构造器用于在创建 CustomException 对象时初始化异常信息。 super(message)：\n这行代码调用了父类 RuntimeException 的构造器，并传递了 message 参数。这样做是为了设置异常的消息，这个信息通常在调试时非常有用，因为它可以提供关于异常原因的详细信息。 总的来说，CustomException 是一个自定义的异常类，你可以在业务逻辑中抛出这个异常来表示特定的业务错误。例如，如果用户输入了无效的数据，你可以抛出一个 CustomException 来表示这个错误，并提供相应的错误消息。\n使用自定义异常的好处是，你可以创建更具体、更有意义的异常类型来表示你的应用程序可能遇到的各种错误情况。这有助于错误处理和调试，也使得异常处理代码更加清晰和易于维护。\n下面是一个使用 CustomException 的例子：\n1 2 3 4 5 6 7 8 9 10 11 public void someBusinessMethod() { try { // 业务逻辑... if (某个条件) { throw new CustomException(\u0026#34;发生了一个业务错误\u0026#34;); } } catch (CustomException e) { // 处理 CustomException e.printStackTrace(); } } 在这个例子中，如果 某个条件 为真，someBusinessMethod 方法将抛出一个 CustomException，异常的消息是 \u0026ldquo;发生了一个业务错误\u0026rdquo;。然后，你可以在 catch 块中捕获并处理这个异常。\n短信发送工具 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 /** * 短信发送工具类 */ public class SMSUtils { /** * 发送短信 * @param signName 签名 * @param templateCode 模板 * @param phoneNumbers 手机号 * @param param 参数 */ public static void sendMessage(String signName, String templateCode,String phoneNumbers,String param){ DefaultProfile profile = DefaultProfile.getProfile(\u0026#34;cn-hangzhou\u0026#34;, \u0026#34;\u0026#34;, \u0026#34;\u0026#34;); IAcsClient client = new DefaultAcsClient(profile); SendSmsRequest request = new SendSmsRequest(); request.setSysRegionId(\u0026#34;cn-hangzhou\u0026#34;); request.setPhoneNumbers(phoneNumbers); request.setSignName(signName); request.setTemplateCode(templateCode); request.setTemplateParam(\u0026#34;{\\\u0026#34;code\\\u0026#34;:\\\u0026#34;\u0026#34;+param+\u0026#34;\\\u0026#34;}\u0026#34;); try { SendSmsResponse response = client.getAcsResponse(request); System.out.println(\u0026#34;短信发送成功\u0026#34;); }catch (ClientException e) { e.printStackTrace(); } } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 /** * 随机生成验证码工具类 */ public class ValidateCodeUtils { /** * 随机生成验证码 * @param length 长度为4位或者6位 * @return */ public static Integer generateValidateCode(int length){ Integer code =null; if(length == 4){ code = new Random().nextInt(9999);//生成随机数，最大为9999 if(code \u0026lt; 1000){ code = code + 1000;//保证随机数为4位数字 } }else if(length == 6){ code = new Random().nextInt(999999);//生成随机数，最大为999999 if(code \u0026lt; 100000){ code = code + 100000;//保证随机数为6位数字 } }else{ throw new RuntimeException(\u0026#34;只能生成4位或6位数字验证码\u0026#34;); } return code; } /** * 随机生成指定长度字符串验证码 * @param length 长度 * @return */ public static String generateValidateCode4String(int length){ Random rdm = new Random(); String hash1 = Integer.toHexString(rdm.nextInt()); String capstr = hash1.substring(0, length); return capstr; } } 文件的上传与回显 用户通过前端将文件（图片等信息）提交，前端将信息发送给后端，后端通过springmvc提供的MultipartFile接收到文件，将文件先转存到本地磁盘的某一地方，接着等前端需要将文件进行回显的时候，就要从本地获取流，通过HttpServletResponse将文件写回浏览器。\n利用@Value将配置文件中的信息更加方便地注入给basePath。\n拿到文件后利用UUID获取一串字符为文件名重新赋值，防止重名导致的文件覆盖，并且将重命名的文件名传给前端，当前端想回显时利用新的文件名进行请求。\n利用File创建出来的是可以带路径的文件，如果路径文件夹不存在，可以通过mkdirs方法进行创建。\n需要设置为response.setContentType(\u0026ldquo;image/jpeg\u0026rdquo;);\n将文件进行回显的时候，通过文件输入流和HttpServletResponse获取输出流，将文件写回到浏览器。\n1 2 3 4 5 6 7 8 response.setContentType(\u0026#34;image/jpeg\u0026#34;); int len = 0; byte[] bytes = new byte[1024]; while ((len = fileInputStream.read(bytes)) != -1){ outputStream.write(bytes,0,len); outputStream.flush(); } 并且要记得关闭资源。\nMultipartFile MultipartFile 是 Spring MVC 提供的一个接口，用于处理 HTTP 请求中的文件上传部分。它极大地简化了文件上传的处理过程，提供了多种方法来访问和操作上传的文件。以下是 MultipartFile 的一些常用方法和使用场景：\nMultipartFile 的常用方法：\ngetOriginalFilename()：获取上传文件的原始文件名。 getContentType()：获取文件的 MIME 类型，这可以帮助你确定文件的类型。 isEmpty()：检查上传的文件是否为空。 getSize()：获取文件的大小，单位是字节。 getBytes()：将文件内容转换为字节数组。 getInputStream()：获取文件内容的输入流。 transferTo(File dest)：将上传的文件保存到服务器的指定路径。 使用场景和示例：\n1. 单文件上传：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @PostMapping(\u0026#34;/upload\u0026#34;) public String handleFileUpload(@RequestParam(\u0026#34;file\u0026#34;) MultipartFile file) { if (file.isEmpty()) { return \u0026#34;文件为空，请选择一个文件上传。\u0026#34;; } try { String originalFilename = file.getOriginalFilename(); File destFile = new File(\u0026#34;/uploads/\u0026#34; + originalFilename); file.transferTo(destFile); return \u0026#34;文件上传成功：\u0026#34; + originalFilename; } catch (IOException e) { e.printStackTrace(); return \u0026#34;文件上传失败：\u0026#34; + e.getMessage(); } } 在这个例子中，我们接收一个名为 file 的文件，并将其保存到服务器的 /uploads/ 目录下。\n2. 多文件上传：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 @PostMapping(\u0026#34;/uploadMultiple\u0026#34;) public String handleMultipleFileUpload(@RequestParam(\u0026#34;files\u0026#34;) MultipartFile[] files) { for (MultipartFile file : files) { if (file.isEmpty()) continue; try { String originalFilename = file.getOriginalFilename(); File destFile = new File(\u0026#34;/uploads/\u0026#34; + originalFilename); file.transferTo(destFile); } catch (IOException e) { e.printStackTrace(); return \u0026#34;文件上传失败：\u0026#34; + e.getMessage(); } } return \u0026#34;所有文件上传成功\u0026#34;; } 在这个例子中，我们接收一个文件数组，并遍历数组中的每个文件，将它们保存到服务器的 /uploads/ 目录下。\n3. 文件下载：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 @GetMapping(\u0026#34;/download\u0026#34;) public void handleFileDownload(HttpServletRequest request, HttpServletResponse response) { String filePath = \u0026#34;/path/to/file.jpg\u0026#34;; File file = new File(filePath); response.setContentType(\u0026#34;application/octet-stream\u0026#34;); response.setHeader(\u0026#34;Content-Disposition\u0026#34;, \u0026#34;attachment; filename=\\\u0026#34;\u0026#34; + file.getName() + \u0026#34;\\\u0026#34;\u0026#34;); try (InputStream in = new FileInputStream(file); OutputStream out = response.getOutputStream()) { byte[] buffer = new byte[8192]; int bytesRead; while ((bytesRead = in.read(buffer)) != -1) { out.write(buffer, 0, bytesRead); } } catch (IOException e) { e.printStackTrace(); } } 在这个例子中，我们提供了一个文件下载的接口，用户可以通过这个接口下载服务器上的文件。\n注意事项：\n文件大小限制：Spring Boot 允许你通过配置文件来限制上传文件的大小，以防止恶意上传大文件。 文件名处理：用户上传的文件名可能包含特殊字符，需要进行适当的处理。 文件存储路径：上传的文件应该存储在安全的路径下，以防止文件被恶意访问。 通过这些方法和示例，你可以熟练地使用 MultipartFile 来处理文件上传和下载的需求。\n@Value 在Spring框架中，@Value 注解用于将配置文件中的值注入到Spring管理的Bean的字段中。这个注解提供了一种方便的方式来将外部配置（如.properties或.yml文件中的值）绑定到Java对象的属性上。\n使用方法：\n@Value 注解可以用于字段、设置方法（setter methods）或普通方法上。当用于字段上时，Spring会在创建Bean时自动将配置值注入到这些字段中。如果用于方法上，Spring会调用这些方法并将配置值作为参数传递。\n基本语法：\n1 2 @Value(\u0026#34;${property.name}\u0026#34;) private String propertyName; 或者，如果你需要进行一些表达式评估，可以使用SpEL（Spring Expression Language）：\n1 2 @Value(\u0026#34;#{systemProperties[\u0026#39;user.home\u0026#39;]}\u0026#34;) private String userHome; 使用场景：\n注入简单值：\n用于将配置文件中的简单值（如字符串、数字等）注入到Bean的字段中。 注入集合或数组：\n可以将配置文件中的列表或数组值注入到Bean的集合或数组字段中。 注入SpEL表达式：\n可以利用SpEL的强大功能，执行更复杂的注入操作，如调用方法、访问环境变量等。 示例代码：\n假设你有一个application.properties配置文件，其中包含以下属性：\n1 2 3 app.name=MyApplication app.description=This is a sample application. app.version=1.0.0 你可以使用@Value注解将这些值注入到Bean中：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 import org.springframework.beans.factory.annotation.Value; import org.springframework.stereotype.Component; @Component public class ApplicationProperties { @Value(\u0026#34;${app.name}\u0026#34;) private String name; @Value(\u0026#34;${app.description}\u0026#34;) private String description; @Value(\u0026#34;${app.version}\u0026#34;) private String version; // Getters and Setters public String getName() { return name; } public void setName(String name) { this.name = name; } public String getDescription() { return description; } public void setDescription(String description) { this.description = description; } public String getVersion() { return version; } public void setVersion(String version) { this.version = version; } } 在这个例子中，ApplicationProperties 类的字段被@Value注解标记，Spring容器在创建这个Bean时会自动从配置文件中读取相应的值并注入到这些字段中。\n注意事项：\n表达式结果为null：如果@Value注解的表达式结果为null，且字段没有初始值，则会抛出异常。为了避免这个问题，你可以为字段提供一个默认值。\n安全性：不要将敏感信息（如密码、密钥等）直接放在配置文件中。可以使用Spring Boot的配置属性替换功能来实现敏感信息的加密和解密。\n类型转换：Spring会尝试将注入的值转换为字段的类型。如果转换失败，会抛出异常。\n@Value 注解提供了一种简单而强大的方式，将外部配置与应用程序代码解耦，使得应用程序更容易配置和维护。\nContent-Type response.setContentType(\u0026quot;image/jpeg\u0026quot;); 这行代码设置了HTTP响应的内容类型（Content-Type）为 image/jpeg。这个头部信息告诉客户端（通常是浏览器）响应的内容是JPEG格式的图片。\n为什么要设置内容类型：\n内容协商：\n内容类型是HTTP内容协商的一部分，它允许客户端根据响应的内容类型决定如何处理这些数据。例如，浏览器会根据内容类型显示图片或执行其他操作。 正确的渲染：\n如果不设置内容类型，或者设置错误，客户端可能无法正确渲染或处理响应内容。例如，浏览器可能不知道如何处理二进制数据，可能会将其视为文本或下载文件。 保存文件时的文件类型：\n当用户通过浏览器下载文件时，正确的内容类型可以提示浏览器以正确的格式保存文件。 安全性：\n某些内容类型可能会触发客户端的安全检查，如执行JavaScript代码。正确的内容类型有助于避免潜在的安全问题。 如果没有设置内容类型可以吗？\n不设置内容类型，HTTP响应默认可能不会有 Content-Type 头部，或者继承自配置的默认值。在某些情况下，即使没有显式设置内容类型，客户端可能仍然能够正确处理响应，特别是如果响应的内容能够被客户端自动识别（例如，某些浏览器可以识别JPEG文件的二进制签名）。\n然而，不设置内容类型可能会导致以下问题：\n客户端行为不确定：\n客户端可能无法确定如何处理响应内容，导致渲染不正确或出现错误。 下载文件时的问题：\n如果用户正在下载文件，没有正确的内容类型，下载的文件可能无法以正确的格式保存。 安全性问题：\n在某些情况下，缺少内容类型可能会绕过客户端的安全检查，导致潜在的安全风险。 因此，为了确保最佳的兼容性和安全性，建议在发送特定类型的响应时总是设置正确的 Content-Type。这是一个良好的实践，可以确保你的应用程序在不同的客户端和环境中表现一致。\nresponse.setContentType 方法用于设置HTTP响应的内容类型（Content-Type），它告诉客户端（如浏览器）响应的内容是什么类型的数据。以下是一些常见的内容类型及其使用场景和示例：\n文本类型：\ntext/html：用于传输HTML文档。当你想返回一个网页时使用此类型。 1 response.setContentType(\u0026#34;text/html; charset=utf-8\u0026#34;); text/plain：用于传输纯文本数据。适用于返回简单的文本信息。 1 response.setContentType(\u0026#34;text/plain; charset=utf-8\u0026#34;); text/xml：用于传输XML数据。常用于配置文件或API响应。 1 response.setContentType(\u0026#34;text/xml; charset=utf-8\u0026#34;); text/css：用于传输CSS样式表。 1 response.setContentType(\u0026#34;text/css; charset=utf-8\u0026#34;); text/javascript：用于传输JavaScript代码。 1 response.setContentType(\u0026#34;text/javascript; charset=utf-8\u0026#34;); 图像类型：\nimage/jpeg：用于传输JPEG格式的图片。 1 response.setContentType(\u0026#34;image/jpeg\u0026#34;); image/png：用于传输PNG格式的图片。 1 response.setContentType(\u0026#34;image/png\u0026#34;); image/gif：用于传输GIF格式的图片。 1 response.setContentType(\u0026#34;image/gif\u0026#34;); 应用类型：\napplication/json：用于传输JSON格式的数据。常用于API响应。 1 response.setContentType(\u0026#34;application/json; charset=utf-8\u0026#34;); application/xml：用于传输XML数据。 1 response.setContentType(\u0026#34;application/xml; charset=utf-8\u0026#34;); application/pdf：用于传输PDF文件。 1 response.setContentType(\u0026#34;application/pdf\u0026#34;); application/zip：用于传输ZIP压缩文件。 1 response.setContentType(\u0026#34;application/zip\u0026#34;); 多部分类型：\nmultipart/form-data：用于文件上传。当表单包含文件上传时使用此类型。 1 response.setContentType(\u0026#34;multipart/form-data; boundary=----WebKitFormBoundaryXXXXX\u0026#34;); multipart/byteranges：用于传输文件的特定部分。 1 response.setContentType(\u0026#34;multipart/byteranges\u0026#34;); 音频和视频类型：\naudio/mpeg：用于传输MP3音频文件。 1 response.setContentType(\u0026#34;audio/mpeg\u0026#34;); video/mp4：用于传输MP4视频文件。 1 response.setContentType(\u0026#34;video/mp4\u0026#34;); 其他类型：\napplication/octet-stream：用于传输二进制流数据，如文件下载。 1 response.setContentType(\u0026#34;application/octet-stream\u0026#34;); application/x-www-form-urlencoded：用于传输表单数据。这是表单提交的默认编码类型。 1 response.setContentType(\u0026#34;application/x-www-form-urlencoded\u0026#34;); 正确设置内容类型对于确保数据正确传输和处理至关重要。例如，如果你返回一个图片文件，但没有设置正确的内容类型，浏览器可能会将响应视为普通文本，导致无法正确显示图片。同样，如果你返回JSON数据，但没有设置application/json类型，客户端可能无法正确解析数据。\n在实际开发中，根据你传输的数据类型选择正确的Content-Type，以确保数据能够被客户端正确处理。\n代码和解析： 1 2 reggie: path: D:\\ 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 /** * 文件上传和下载 */ @RestController @RequestMapping(\u0026#34;/common\u0026#34;) @Slf4j public class CommonController { @Value(\u0026#34;${reggie.path}\u0026#34;) private String basePath; /** * 文件上传 * @param file * @return */ @PostMapping(\u0026#34;/upload\u0026#34;) public R\u0026lt;String\u0026gt; upload(MultipartFile file){ //file是一个临时文件，需要转存到指定位置，否则本次请求完成后临时文件会删除 log.info(file.toString()); //原始文件名 String originalFilename = file.getOriginalFilename();//abc.jpg String suffix = originalFilename.substring(originalFilename.lastIndexOf(\u0026#34;.\u0026#34;)); //使用UUID重新生成文件名，防止文件名称重复造成文件覆盖 String fileName = UUID.randomUUID().toString() + suffix;//dfsdfdfd.jpg //创建一个目录对象 File dir = new File(basePath); //判断当前目录是否存在 if(!dir.exists()){ //目录不存在，需要创建 dir.mkdirs(); } try { //将临时文件转存到指定位置 file.transferTo(new File(basePath + fileName)); } catch (IOException e) { e.printStackTrace(); } return R.success(fileName); } /** * 文件下载 * @param name * @param response */ @GetMapping(\u0026#34;/download\u0026#34;) public void download(String name, HttpServletResponse response){ try { //输入流，通过输入流读取文件内容 FileInputStream fileInputStream = new FileInputStream(new File(basePath + name)); //输出流，通过输出流将文件写回浏览器 ServletOutputStream outputStream = response.getOutputStream(); response.setContentType(\u0026#34;image/jpeg\u0026#34;); int len = 0; byte[] bytes = new byte[1024]; while ((len = fileInputStream.read(bytes)) != -1){ outputStream.write(bytes,0,len); outputStream.flush(); } //关闭资源 outputStream.close(); fileInputStream.close(); } catch (Exception e) { e.printStackTrace(); } } } 这段代码是一个Spring Boot控制器CommonController，它提供了文件上传和下载的功能。下面我将逐行解释这段代码：\n@RestController：\n这个注解表明这个类是一个REST控制器，意味着类中的方法会返回数据而不是视图。它相当于@Controller和@ResponseBody的组合。 @RequestMapping(\u0026quot;/common\u0026quot;)：\n这个注解用于映射Web请求到控制器的处理方法上。在这里，它指定了所有请求的URL前缀为/common。 @Slf4j：\n这是Lombok库提供的一个注解，用于自动为类生成一个日志对象（private static final Logger log = LoggerFactory.getLogger(CommonController.class);）。 @Value(\u0026quot;${reggie.path}\u0026quot;)：\n这个注解用于从Spring Boot的配置文件中注入配置值。在这里，它注入了配置文件中reggie.path的值，通常用于指定文件存储的路径。 private String basePath;：\n这是一个类的字段，用于存储文件的存储路径。 @PostMapping(\u0026quot;/upload\u0026quot;)：\n这个注解用于映射POST请求到upload方法上。这意味着当有POST请求发送到/common/upload时，会调用这个方法。 public R\u0026lt;String\u0026gt; upload(MultipartFile file)：\n这是一个处理文件上传的方法。它接受一个MultipartFile类型的参数，这个参数是由Spring MVC自动解析上传的文件。 log.info(file.toString());：\n使用日志记录器记录上传的文件信息。 String originalFilename = file.getOriginalFilename();：\n获取上传文件的原始文件名。 String suffix = originalFilename.substring(originalFilename.lastIndexOf(\u0026quot;.\u0026quot;));：\n从原始文件名中提取文件后缀。 String fileName = UUID.randomUUID().toString() + suffix;：\n生成一个新的文件名，使用UUID确保文件名唯一，防止文件名冲突。 File dir = new File(basePath);：\n创建一个File对象，指向存储文件的目录。 if(!dir.exists()){ dir.mkdirs(); }：\n检查目录是否存在，如果不存在则创建它。 file.transferTo(new File(basePath + fileName));：\n将上传的临时文件移动到指定的存储路径。 return R.success(fileName);：\n返回一个成功的响应，包含新生成的文件名。 接下来是文件下载的方法：\n@GetMapping(\u0026quot;/download\u0026quot;)：\n这个注解用于映射GET请求到download方法上。这意味着当有GET请求发送到/common/download时，会调用这个方法。 public void download(String name, HttpServletResponse response)：\n这是一个处理文件下载的方法。它接受文件名和HttpServletResponse对象作为参数。 FileInputStream fileInputStream = new FileInputStream(new File(basePath + name));：\n创建一个文件输入流，用于读取要下载的文件。 ServletOutputStream outputStream = response.getOutputStream();：\n获取HttpServletResponse的输出流，用于将文件内容写回客户端。 response.setContentType(\u0026quot;image/jpeg\u0026quot;);：\n设置响应的内容类型，这里假设文件是JPEG图片。 int len = 0; byte[] bytes = new byte[1024];：\n定义一个缓冲区，用于存储从文件中读取的数据。 while ((len = fileInputStream.read(bytes)) != -1){ outputStream.write(bytes,0,len); outputStream.flush(); }：\n读取文件内容，并写入到响应的输出流中。 outputStream.close(); fileInputStream.close();：\n关闭打开的流资源。 这个方法通过读取服务器上的文件并将其写入HTTP响应，允许客户端下载文件。需要注意的是，这个方法没有处理异常，实际使用时应该添加适当的异常处理逻辑。此外，basePath应该是一个有效的目录路径，并且在运行应用程序的服务器上可写。\nDTO 它可以说是为了更好的接收和发送数据等，对本来已经有的entity类进行加强。\n接收DTO 例如：\n本来Dish就只有这么多属性，但是现在前端给它传输的不止这些属性，还有一个口味的集合，因此如果想要用@RequestBody Dish dish来就收前端发送过来的请求就没法接收到全部信息了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 /** 菜品 */ @Data public class Dish implements Serializable { private static final long serialVersionUID = 1L; private Long id; private String name; private Long categoryId; private BigDecimal price; private String code; private String image; private String description; private Integer status; private Integer sort; @TableField(fill = FieldFill.INSERT) private LocalDateTime createTime; @TableField(fill = FieldFill.INSERT_UPDATE) private LocalDateTime updateTime; @TableField(fill = FieldFill.INSERT) private Long createUser; @TableField(fill = FieldFill.INSERT_UPDATE) private Long updateUser; } 此时可以利用Dto类。\n将DishDto继承Dish类，就意味着它里面有了Dish的全部属性。现在又往里面添加了一些属性，就形成了Dish的加强类，例如用List集合接收口味的集合。\n1 2 3 4 5 6 7 8 9 10 @Data public class DishDto extends Dish { //菜品对应的口味数据 private List\u0026lt;DishFlavor\u0026gt; flavors = new ArrayList\u0026lt;\u0026gt;(); private String categoryName; private Integer copies; } 此时就可以用DishDto类进行接收信息，但是呢就不能调用MP默认实现的方法了，需要自定义方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 /** * 新增菜品 * @param dishDto * @return */ @PostMapping public R\u0026lt;String\u0026gt; save(@RequestBody DishDto dishDto){ log.info(dishDto.toString()); dishService.saveWithFlavor(dishDto); return R.success(\u0026#34;新增菜品成功\u0026#34;); } 1 2 3 4 5 6 7 8 9 10 11 public interface DishService extends IService\u0026lt;Dish\u0026gt; { //新增菜品，同时插入菜品对应的口味数据，需要操作两张表：dish、dish_flavor public void saveWithFlavor(DishDto dishDto); //根据id查询菜品信息和对应的口味信息 public DishDto getByIdWithFlavor(Long id); //更新菜品信息，同时更新对应的口味信息 public void updateWithFlavor(DishDto dishDto); } 利用已经纳入spring容器管理的DishServiceImpl类，对自身进行处理。\n利用this.save(dishDto);将其中的菜品的属性保存起来，那些多出来的属性就不处理。\n接着对其它属性进行处理。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 @Service @Slf4j public class DishServiceImpl extends ServiceImpl\u0026lt;DishMapper,Dish\u0026gt; implements DishService { @Autowired private DishFlavorService dishFlavorService; /** * 新增菜品，同时保存对应的口味数据 * @param dishDto */ @Transactional public void saveWithFlavor(DishDto dishDto) { //保存菜品的基本信息到菜品表dish this.save(dishDto); Long dishId = dishDto.getId();//菜品id //菜品口味 List\u0026lt;DishFlavor\u0026gt; flavors = dishDto.getFlavors(); flavors = flavors.stream().map((item) -\u0026gt; { item.setDishId(dishId); return item; }).collect(Collectors.toList()); //保存菜品口味数据到菜品口味表dish_flavor dishFlavorService.saveBatch(flavors); } } 发送DTO 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 /** * 菜品信息分页查询 * @param page * @param pageSize * @param name * @return */ @GetMapping(\u0026#34;/page\u0026#34;) public R\u0026lt;Page\u0026gt; page(int page,int pageSize,String name){ //构造分页构造器对象。之所以要有两个，而不直接使用前端需要的DishDto，原因是它并没有对应的各种service、mapper层。 //那么变先将Dish的Page作为桥梁，将其中的数据经过处理转入到DishDto的Page对象里，接着返回给前端。 Page\u0026lt;Dish\u0026gt; pageInfo = new Page\u0026lt;\u0026gt;(page,pageSize); Page\u0026lt;DishDto\u0026gt; dishDtoPage = new Page\u0026lt;\u0026gt;(); //条件构造器 LambdaQueryWrapper\u0026lt;Dish\u0026gt; queryWrapper = new LambdaQueryWrapper\u0026lt;\u0026gt;(); //添加过滤条件 queryWrapper.like(name != null,Dish::getName,name); //添加排序条件 queryWrapper.orderByDesc(Dish::getUpdateTime); //执行分页查询，此时执行过了pageInfo就会包含分页的相关信息 dishService.page(pageInfo,queryWrapper); //对象拷贝，利用spring框架提供的工具类，对类之间数据的转移进行传递，先将获取到的分页后的信息忽略了，因为 //那些信息还需要经过处理才能被使用，等处理好了再放进去，要不然重新覆盖影响效率。 BeanUtils.copyProperties(pageInfo,dishDtoPage,\u0026#34;records\u0026#34;); //获取分页后的具体内容信息 List\u0026lt;Dish\u0026gt; records = pageInfo.getRecords(); //此处对于集合中数据的处理，利用了stream流 List\u0026lt;DishDto\u0026gt; list = records.stream().map((item) -\u0026gt; { DishDto dishDto = new DishDto(); BeanUtils.copyProperties(item,dishDto); Long categoryId = item.getCategoryId();//分类id //根据id查询分类对象 Category category = categoryService.getById(categoryId); if(category != null){ String categoryName = category.getName(); dishDto.setCategoryName(categoryName); } return dishDto; }).collect(Collectors.toList()); dishDtoPage.setRecords(list); return R.success(dishDtoPage); } 像这个也是同种类型的\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 @GetMapping(\u0026#34;/list\u0026#34;) public R\u0026lt;List\u0026lt;DishDto\u0026gt;\u0026gt; list(Dish dish){ //构造查询条件 LambdaQueryWrapper\u0026lt;Dish\u0026gt; queryWrapper = new LambdaQueryWrapper\u0026lt;\u0026gt;(); queryWrapper.eq(dish.getCategoryId() != null ,Dish::getCategoryId,dish.getCategoryId()); //添加条件，查询状态为1（起售状态）的菜品 queryWrapper.eq(Dish::getStatus,1); //添加排序条件 queryWrapper.orderByAsc(Dish::getSort).orderByDesc(Dish::getUpdateTime); List\u0026lt;Dish\u0026gt; list = dishService.list(queryWrapper); List\u0026lt;DishDto\u0026gt; dishDtoList = list.stream().map((item) -\u0026gt; { DishDto dishDto = new DishDto(); BeanUtils.copyProperties(item,dishDto); Long categoryId = item.getCategoryId();//分类id //根据id查询分类对象 Category category = categoryService.getById(categoryId); if(category != null){ String categoryName = category.getName(); dishDto.setCategoryName(categoryName); } //当前菜品的id Long dishId = item.getId(); LambdaQueryWrapper\u0026lt;DishFlavor\u0026gt; lambdaQueryWrapper = new LambdaQueryWrapper\u0026lt;\u0026gt;(); lambdaQueryWrapper.eq(DishFlavor::getDishId,dishId); //SQL:select * from dish_flavor where dish_id = ? List\u0026lt;DishFlavor\u0026gt; dishFlavorList = dishFlavorService.list(lambdaQueryWrapper); dishDto.setFlavors(dishFlavorList); return dishDto; }).collect(Collectors.toList()); return R.success(dishDtoList); } Service和Controller层经常用到的知识点 @RestController @RestController 是 Spring Framework 中的一个注解，用于定义 RESTful 控制器。这个注解是 @Controller 和 @ResponseBody 注解的组合，它表明该控制器中的所有方法都会自动将返回值作为 HTTP 响应的正文（Body），并且不需要返回视图（View）。\n下面是 @RestController 注解的一些关键点：\n注解组合：\n@RestController 是一个组合注解，它本身就包含了 @Controller 和 @ResponseBody。 @Controller 表示该类是一个控制器，用于处理 HTTP 请求。 @ResponseBody 表示该控制器中的方法返回值将直接作为 HTTP 响应正文返回。 自动序列化：\n当你使用 @RestController 注解时，Spring MVC 会自动将方法的返回值序列化为 JSON（或其他格式，取决于配置的消息转换器）并写入 HTTP 响应正文中。 无需视图解析器：\n由于 @RestController 包含了 @ResponseBody，所以不需要 Spring 的视图解析器来解析返回值。这意味着你可以返回任意的 Java 对象，而不需要担心它们如何被渲染为 HTML。 简化代码：\n使用 @RestController 可以简化代码，因为你不需要在每个方法上都添加 @ResponseBody 注解。 RESTful API：\n@RestController 通常用于构建 RESTful API，因为它使得返回 JSON 数据变得非常简单。 下面是一个使用 @RestController 注解的简单示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import org.springframework.web.bind.annotation.GetMapping; import org.springframework.web.bind.annotation.RestController; @RestController public class MyRestController { @GetMapping(\u0026#34;/hello\u0026#34;) public String sayHello() { return \u0026#34;Hello, World!\u0026#34;; } @GetMapping(\u0026#34;/users/{id}\u0026#34;) public User getUserById(@PathVariable Long id) { // 假设这里通过 id 获取用户信息 return new User(id, \u0026#34;John Doe\u0026#34;); } } 在这个例子中，MyRestController 类使用了 @RestController 注解，所以它的所有方法都会自动将返回值作为 HTTP 响应正文返回。sayHello 方法返回一个简单的字符串，而 getUserById 方法返回一个 User 对象，这个对象将被自动序列化为 JSON 格式。\n使用 @RestController 注解是创建 RESTful Web 服务时的一种常见做法，它使得控制器代码更加简洁和专注于业务逻辑。\n@RequestMapping @RequestMapping 是 Spring Framework 中的一个注解，用于将 HTTP 请求映射到特定的处理方法上。这个注解可以用于定义请求的类型、路径以及其他映射信息，它表明了控制器中的方法如何处理特定的 HTTP 请求。\n以下是 @RequestMapping 注解的一些关键特性：\n请求类型：\n可以通过 method 属性指定请求的类型，如 GET、POST、PUT、DELETE 等。 请求路径：\n可以通过 value 或 path 属性指定请求的路径。value 是 path 的别名，两者可以互换使用。 参数条件：\n可以通过 params 属性指定请求参数的条件，只有当这些条件满足时，请求才会映射到对应的方法。 头部条件：\n可以通过 headers 属性指定请求头部的条件。 请求消费类型：\n可以通过 consumes 属性指定请求体可以消费的媒体类型。 请求产生类型：\n可以通过 produces 属性指定响应可以产生的媒体类型。 组合使用：\n可以在同一个方法上使用多个 @RequestMapping 注解，来处理不同的路径或请求类型。 继承：\n@RequestMapping 注解可以继承，这意味着你可以在控制器类上使用 @RequestMapping 来定义一个基础路径，然后在该类的方法上使用 @RequestMapping 来定义相对路径。 下面是一个使用 @RequestMapping 注解的示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import org.springframework.web.bind.annotation.RequestMapping; import org.springframework.web.bind.annotation.RequestMethod; import org.springframework.web.bind.annotation.RestController; @RestController public class MyController { // 映射 GET 请求到 \u0026#34;/employees\u0026#34; 路径 @RequestMapping(value = \u0026#34;/employees\u0026#34;, method = RequestMethod.GET) public List\u0026lt;Employee\u0026gt; getAllEmployees() { // 返回所有员工信息 return employeeService.getAllEmployees(); } // 映射 POST 请求到 \u0026#34;/employees\u0026#34; 路径 @RequestMapping(value = \u0026#34;/employees\u0026#34;, method = RequestMethod.POST) public Employee createEmployee(@RequestBody Employee employee) { // 创建一个新的员工 return employeeService.createEmployee(employee); } } 在这个例子中，MyController 类中的两个方法分别处理不同的 HTTP 请求类型。getAllEmployees 方法处理 GET 请求，返回所有员工的信息；createEmployee 方法处理 POST 请求，创建一个新的员工记录。\n使用 @RequestMapping 注解可以清晰地定义控制器方法与 HTTP 请求之间的关系，使得代码更加模块化和易于维护。\n@Slf4j @Slf4j 是 Lombok 库提供的一个注解，用于在类中自动生成一个日志对象。当你在类上使用 @Slf4j 注解时，Lombok 会在编译期间为你生成一个日志实例，通常是 private static final Logger log = LoggerFactory.getLogger(YourClass.class); 这样的形式。\n下面是 @Slf4j 注解的一些关键点：\n日志实例：\n@Slf4j 注解会自动为你的类创建一个日志实例，你可以直接在类的方法中使用这个实例来记录日志。 无需手动创建：\n使用 @Slf4j 注解后，你不需要手动创建日志对象，这简化了代码，特别是在有许多日志记录的类中。 支持多种日志框架：\nLombok 支持多种日志框架，包括 SLF4J、Log4j、Java Util Logging 等。@Slf4j 注解特别为 SLF4J 日志框架生成日志实例。 线程安全：\n自动生成的日志实例是线程安全的，可以在多线程环境中使用。 性能：\n使用 @Slf4j 注解生成的日志实例通常比手动创建的日志实例性能更好，因为它们是通过注解在编译时生成的。 灵活性：\n你可以选择在类级别使用 @Slf4j 注解，或者在方法级别使用其他 Lombok 日志注解，如 @Log（Log4j）、@Logger（Java Util Logging）等。 下面是一个使用 @Slf4j 注解的示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import lombok.extern.slf4j.Slf4j; @Slf4j public class MyClass { public void doSomething() { log.info(\u0026#34;Doing something\u0026#34;); // 如果发生异常 try { // 一些可能抛出异常的代码 } catch (Exception e) { log.error(\u0026#34;Error occurred\u0026#34;, e); } } } 在这个例子中，MyClass 类使用了 @Slf4j 注解，因此它自动获得了一个日志实例 log。在 doSomething 方法中，你可以使用 log 来记录不同级别的日志信息。\n使用 @Slf4j 注解可以显著减少样板代码，让你更专注于业务逻辑。此外，它还有助于保持代码的整洁和一致性。\n@Data @Data 是 Lombok 库提供的一个注解，用于在类上自动生成一系列的常用方法，包括：\ngetter 和 setter 方法：为类的每个字段生成对应的获取（getter）和设置（setter）方法。\ntoString() 方法：生成一个包含所有字段值的字符串表示形式的方法。\nequals() 方法：生成一个比较两个对象是否相等的方法，通常基于所有字段的值进行比较。\nhashCode() 方法：生成一个基于对象字段值的哈希码计算方法。\n使用 @Data 注解可以显著减少在 Java 类中编写样板代码的工作量，让你更专注于业务逻辑的实现。下面是一个使用 @Data 注解的示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 import lombok.Data; @Data public class User { private String name; private int age; private String email; // 使用 @Data 注解后，以下方法将自动生成： // - name() getter 方法 // - setName(String name) setter 方法 // - age() getter 方法 // - setAge(int age) setter 方法 // - email() getter 方法 // - setEmail(String email) setter 方法 // - User [name=Kimi, age=30, email=kimi@moonshot.cn] toString() 方法 // - equals(Object o) 方法 // - hashCode() 方法 } 在这个例子中，User 类使用了 @Data 注解，因此 Lombok 会在编译时自动为这个类的每个字段生成 getter 和 setter 方法，以及 toString()、equals() 和 hashCode() 方法。\n使用 @Data 注解的好处包括：\n减少代码量：自动生成的方法减少了手动编写这些常用方法的需要。 保持一致性：自动生成的方法遵循一致的编码风格和逻辑。 提高效率：减少了编写和维护样板代码的时间，提高了开发效率。 减少错误：自动生成的方法减少了手动编写方法时可能出现的错误。 请注意，为了使用 Lombok 注解，你需要在项目中引入 Lombok 库，并确保你的 IDE 支持 Lombok 插件。这样，当你编译项目时，Lombok 会在编译期间自动为你生成所有注解指定的代码。\n@RequiredArgsConstructor @RequiredArgsConstructor 是 Lombok 提供的一个注解，它用于在类上自动生成一个构造函数，这个构造函数包括所有被标记为 final 的成员变量以及用 @NonNull 注解标记的成员变量。这个注解大大简化了必须参数的构造函数的编写，尤其是在需要注入依赖或常量值时。\n以下是 @RequiredArgsConstructor 注解的一些关键点：\n自动生成构造函数：\n@RequiredArgsConstructor 会为类生成一个构造函数，包含所有 final 字段和标记为 @NonNull 的字段作为参数。 减少代码量：\n使用 @RequiredArgsConstructor 可以避免手动编写构造函数，从而减少代码量。 强制依赖注入：\n通过生成的构造函数，可以实现依赖的自动注入，这对于 Spring 框架中的依赖注入尤为重要。 支持不变性：\n对于被标记为 final 的字段，一旦它们通过构造函数被赋值后，就不能被更改，这有助于创建更稳定、可预测的代码。 清晰的依赖关系：\n自动生成的构造函数明确要求必须提供所有必需的依赖，这使得开发者在使用类的时候更加清晰地了解到哪些依赖是必须的。 使用示例：\n1 2 3 4 5 6 7 8 import lombok.RequiredArgsConstructor; import org.springframework.stereotype.Service; @Service @RequiredArgsConstructor public class MyService { private final MyDependency dependency; } 在这个例子中，MyService 类使用了 @RequiredArgsConstructor 注解，因此 Lombok 会生成一个构造函数，该构造函数要求必须提供 MyDependency 的一个实例。这样，Spring 就可以通过这个构造函数自动注入 MyDependency 的实例。\n需要注意的是，使用 @RequiredArgsConstructor 注解时，需要注入的类成员变量必须被声明为 final，或者使用 @NonNull 注解标记为非空。这样可以确保这些依赖在使用前已经被正确初始化。\n@Autowired @Autowired 是 Spring 框架中使用的一个注解，用于实现依赖注入。当你在一个字段、构造函数、设置方法（setter method）或者普通方法（non-constructor, non-setter method）上使用 @Autowired 注解时，Spring 容器在创建 Bean 实例时会自动注入相应的依赖。\n以下是 @Autowired 注解的一些关键特性：\n自动注入：\nSpring 会自动注入与注解标记的字段、构造函数或方法参数相匹配的 Bean。 按类型注入：\n默认情况下，@Autowired 按照类型（by type）进行注入，这意味着如果存在多个相同类型的 Bean，Spring 将抛出异常，除非你使用 @Qualifier 注解指定具体的 Bean 名称。 按名称注入：\n通过结合使用 @Autowired 和 @Qualifier 注解，可以按照 Bean 的名称（by name）进行注入。 构造函数注入：\n当 @Autowired 注解用于构造函数时，Spring 将使用构造函数注入（constructor injection）的方式创建 Bean 实例。 设置方法注入：\n当 @Autowired 注解用于设置方法（如 setSomething(Something something)）时，Spring 将调用该方法注入依赖。 字段注入：\n当 @Autowired 注解直接用于字段时，Spring 将直接注入依赖到该字段。 可选依赖：\n可以通过设置 @Autowired 注解的 required 属性为 false 来标记某个依赖是可选的。如果该依赖不存在，Spring 不会抛出异常。 在普通方法上的使用：\n从 Spring 4.3 开始，@Autowired 也可以用于普通方法上，这允许更灵活的依赖注入方式。 下面是一个使用 @Autowired 注解的示例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 import org.springframework.beans.factory.annotation.Autowired; import org.springframework.stereotype.Component; @Component public class MyComponent { private final MyDependency myDependency; @Autowired public MyComponent(MyDependency myDependency) { this.myDependency = myDependency; } // 或者使用设置方法注入 @Autowired public void setMyDependency(MyDependency myDependency) { this.myDependency = myDependency; } // 或者直接在字段上使用 @Autowired private MyDependency myDependency; // 使用 @Qualifier 按名称注入 @Autowired private MyDependency myDependency; public void doSomething() { myDependency.doSomething(); } } 在这个例子中，MyComponent 类通过构造函数注入的方式注入了 MyDependency 的实例。如果 MyDependency 只有一个 Bean 定义，Spring 将自动注入这个 Bean。如果有多个 MyDependency 类型的 Bean，你需要使用 @Qualifier 来指定注入哪一个。\n使用 @Autowired 注解可以显著减少配置工作量，使代码更简洁，并且有助于实现松耦合和更高的测试性。\nBeanUtils类 BeanUtils 是 Spring 框架提供的一个实用工具类，位于 org.springframework.beans 包中。它主要用于简化 JavaBean 对象之间的属性拷贝和赋值操作。以下是 BeanUtils 中一些常用方法的使用方法和案例：\n1. BeanUtils.copyProperties(source, target)\n这个方法用于将一个 JavaBean 对象（source）的属性值复制到另一个 JavaBean 对象（target）中。它会自动匹配两个 Bean 对象中相同名称的属性，并将源 Bean 对象中对应属性的值复制到目标 Bean 对象中。\n使用方法：\n1 BeanUtils.copyProperties(sourceBean, targetBean); 案例： 假设我们有两个类 User 和 UserDto，我们想将 User 对象的属性复制到 UserDto 对象中：\n1 2 3 4 5 6 User user = new User(); user.setId(1L); user.setName(\u0026#34;John Doe\u0026#34;); UserDto userDto = new UserDto(); BeanUtils.copyProperties(user, userDto); 在这个例子中，user 对象的 id 和 name 属性将被复制到 userDto 对象中 。\n2. BeanUtils.copyProperties(dest, orig, ignoreProperties)\n这个方法是在 copyProperties 的基础上，增加了忽略特定属性的功能。当你不想复制某些属性时，可以使用这个方法。\n使用方法：\n1 BeanUtils.copyProperties(sourceBean, targetBean, \u0026#34;ignoreProperty1\u0026#34;, \u0026#34;ignoreProperty2\u0026#34;); 案例： 假设我们不想复制 User 对象的 password 属性：\n1 2 3 4 5 6 7 User user = new User(); user.setId(1L); user.setName(\u0026#34;John Doe\u0026#34;); user.setPassword(\u0026#34;secret\u0026#34;); UserDto userDto = new UserDto(); BeanUtils.copyProperties(user, userDto, \u0026#34;password\u0026#34;); 在这个例子中，user 对象的 id 和 name 属性将被复制到 userDto 对象中，但 password 属性将被忽略 。\n3. BeanUtils.copyProperties(dest, orig, Class\u0026lt;?\u0026gt; editable)\n这个方法允许你指定一个编辑类，只有在这个类中定义的属性才会被复制。\n使用方法：\n1 BeanUtils.copyProperties(sourceBean, targetBean, SomeInterface.class); 案例： 假设我们有一个接口 Auditable，它定义了 createdBy 和 createdDate 属性。我们只想复制实现了这个接口的类的属性：\n1 2 3 Auditable auditable = new SomeAuditableImpl(); User user = new User(); BeanUtils.copyProperties(auditable, user, Auditable.class); 在这个例子中，只有 Auditable 接口中定义的属性将被复制到 user 对象中 。\n注意事项：\n属性名称和类型匹配：源对象和目标对象的属性名必须相同，类型也需要匹配或可以自动转换。 浅拷贝：BeanUtils.copyProperties 实现的是浅拷贝，即如果属性是引用类型，复制的是引用而不是实际的对象 。 null值覆盖：默认情况下，源对象中的 null 值属性会覆盖目标对象中对应的属性值 。 安全性：使用反射可能会带来安全风险，需要确保代码的安全性。 性能：反射机制可能会影响性能，尤其是在性能敏感的场景下 。 通过这些方法，你可以灵活地在不同的 JavaBean 对象之间复制属性，从而简化代码并提高开发效率。\nMD5以及其它加密算法 在现代密码学中，有多种加密算法被认为比MD5更安全，以下是一些常用的加密算法及其特点：\nSHA-256：\nSHA-256（Secure Hash Algorithm 256）是SHA-2家族中的一种加密哈希函数。它生成一个256位（32字节）的哈希值，对输入数据进行唯一的固定大小哈希值映射。 特点包括数据完整性验证、唯一性和不可逆性。SHA-256在区块链技术中被广泛使用，如比特币区块链。 SHA-512：\nSHA-512是SHA-2家族中的另一种加密哈希函数，它生成一个512位（64字节）的哈希值。 它比SHA-256提供更高的安全性，因为哈希值更长，但计算速度较慢。通常用于存储高度敏感数据的场景。 Argon2：\nArgon2是一种内存硬哈希函数，设计用于密码哈希，需要大量内存来计算哈希值，这使得它非常适合用于保护密码。 Argon2在2015年赢得了密码哈希竞赛，被选为新的密码哈希标准。它能有效抵抗暴力破解攻击。 bcrypt：\nbcrypt是一种专门设计用于密码存储的哈希函数，它通过使用“代价函数”来增加破解密码的难度。 bcrypt在哈希计算过程中使用盐值（salt）和多次迭代来增强安全性，被广泛用于保护用户密码。 AES（Advanced Encryption Standard）：\nAES是一个广泛使用的对称加密标准，用于保护电子数据的安全性。 AES支持多种密钥长度（128、192、256位），并且因其强大的安全性和较高的效率而被许多组织采用。 ECC（Elliptic-curve cryptography）：\nECC是一种基于椭圆曲线数学的公钥加密技术，它提供了与非对称加密算法（如RSA）相比更短的密钥长度和更高的安全性。 ECC在需要高效密钥交换和数字签名的场景中非常有用。 Twofish：\nTwofish是一种对称密钥加密算法，由Bruce Schneier设计，用于替代Blowfish和DES。 Twofish使用128至256位的密钥长度，提供了强大的安全性和较快的处理速度。 Quantum-resistant algorithms：\n随着量子计算的发展，一些加密算法可能在未来面临安全威胁。为了应对这一挑战，NIST（美国国家标准与技术研究院）已经选择了一些量子抗性加密算法，如CRYSTALS-Kyber、CRYSTALS-Dilithium、FALCON和SPHINCS+。这些算法基于结构化格和哈希函数，旨在抵御量子计算机的攻击。 选择哪种加密算法取决于具体的应用场景、数据敏感性、性能要求和安全需求。对于需要高安全性的应用，推荐使用SHA-256、SHA-512、Argon2或AES等算法。对于需要抵御量子计算攻击的场景，可以考虑使用NIST推荐的量子抗性加密算法。\n移动端本地验证码生成和登录 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 package com.itheima.reggie.utils; import java.util.Random; /** * 随机生成验证码工具类 */ public class ValidateCodeUtils { /** * 随机生成验证码 * @param length 长度为4位或者6位 * @return */ public static Integer generateValidateCode(int length){ Integer code =null; if(length == 4){ code = new Random().nextInt(9999);//生成随机数，最大为9999 if(code \u0026lt; 1000){ code = code + 1000;//保证随机数为4位数字 } }else if(length == 6){ code = new Random().nextInt(999999);//生成随机数，最大为999999 if(code \u0026lt; 100000){ code = code + 100000;//保证随机数为6位数字 } }else{ throw new RuntimeException(\u0026#34;只能生成4位或6位数字验证码\u0026#34;); } return code; } /** * 随机生成指定长度字符串验证码 * @param length 长度 * @return */ public static String generateValidateCode4String(int length){ Random rdm = new Random(); String hash1 = Integer.toHexString(rdm.nextInt()); String capstr = hash1.substring(0, length); return capstr; } } 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 @RestController @RequestMapping(\u0026#34;/user\u0026#34;) @Slf4j public class UserController { @Autowired private UserService userService; /** * 发送手机短信验证码 * @param user * @return */ @PostMapping(\u0026#34;/sendMsg\u0026#34;) public R\u0026lt;String\u0026gt; sendMsg(@RequestBody User user, HttpSession session){ //获取手机号 String phone = user.getPhone(); if(StringUtils.isNotEmpty(phone)){ //生成随机的4位验证码 String code = ValidateCodeUtils.generateValidateCode(4).toString(); log.info(\u0026#34;code={}\u0026#34;,code); //调用阿里云提供的短信服务API完成发送短信 //SMSUtils.sendMessage(\u0026#34;瑞吉外卖\u0026#34;,\u0026#34;\u0026#34;,phone,code); //需要将生成的验证码保存到Session session.setAttribute(phone,code); return R.success(\u0026#34;手机验证码短信发送成功\u0026#34;); } return R.error(\u0026#34;短信发送失败\u0026#34;); } /** * 移动端用户登录 * @param map * @param session * @return */ @PostMapping(\u0026#34;/login\u0026#34;) public R\u0026lt;User\u0026gt; login(@RequestBody Map map, HttpSession session){ log.info(map.toString()); //获取手机号 String phone = map.get(\u0026#34;phone\u0026#34;).toString(); //获取验证码 String code = map.get(\u0026#34;code\u0026#34;).toString(); //从Session中获取保存的验证码 Object codeInSession = session.getAttribute(phone); //进行验证码的比对（页面提交的验证码和Session中保存的验证码比对） if(codeInSession != null \u0026amp;\u0026amp; codeInSession.equals(code)){ //如果能够比对成功，说明登录成功 LambdaQueryWrapper\u0026lt;User\u0026gt; queryWrapper = new LambdaQueryWrapper\u0026lt;\u0026gt;(); queryWrapper.eq(User::getPhone,phone); User user = userService.getOne(queryWrapper); if(user == null){ //判断当前手机号对应的用户是否为新用户，如果是新用户就自动完成注册 user = new User(); user.setPhone(phone); user.setStatus(1); userService.save(user); } session.setAttribute(\u0026#34;user\u0026#34;,user.getId()); return R.success(user); } return R.error(\u0026#34;登录失败\u0026#34;); } } 其它的都是一些逻辑性的东西，以及m和mp的知识点，和stream流 成功\n","date":"2024-01-06T00:00:00Z","image":"https://gkxgithub.github.io/6bca15b627dacad59c574b85416e62e.jpg","permalink":"https://gkxgithub.github.io/p/%E7%91%9E%E5%90%89%E5%A4%96%E5%8D%96%E9%A1%B9%E7%9B%AE%E4%BB%A3%E7%A0%81%E8%A7%A3%E8%AF%BB/","title":"瑞吉外卖项目代码解读"},{"content":"正文测试 而这些并不是完全重要，更加重要的问题是， 带着这些问题，我们来审视一下学生会退会。 既然如何， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 我们不得不面对一个非常尴尬的事实，那就是， 可是，即使是这样，学生会退会的出现仍然代表了一定的意义。 学生会退会，发生了会如何，不发生又会如何。 经过上述讨论， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 学生会退会，到底应该如何实现。 这样看来， 在这种困难的抉择下，本人思来想去，寝食难安。 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 就我个人来说，学生会退会对我的意义，不能不说非常重大。 莎士比亚曾经提到过，人的一生是短的，但如果卑劣地过这一生，就太长了。这似乎解答了我的疑惑。 莫扎特说过一句富有哲理的话，谁和我一样用功，谁就会和我一样成功。这启发了我， 对我个人而言，学生会退会不仅仅是一个重大的事件，还可能会改变我的人生。 学生会退会，到底应该如何实现。 一般来说， 从这个角度来看， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 在这种困难的抉择下，本人思来想去，寝食难安。 了解清楚学生会退会到底是一种怎么样的存在，是解决一切问题的关键。 一般来说， 生活中，若学生会退会出现了，我们就不得不考虑它出现了的事实。 问题的关键究竟为何？ 而这些并不是完全重要，更加重要的问题是。\n奥斯特洛夫斯基曾经说过，共同的事业，共同的斗争，可以使人们产生忍受一切的力量。　带着这句话，我们还要更加慎重的审视这个问题： 一般来讲，我们都必须务必慎重的考虑考虑。 既然如此， 这种事实对本人来说意义重大，相信对这个世界也是有一定意义的。 带着这些问题，我们来审视一下学生会退会。 我认为， 我认为， 在这种困难的抉择下，本人思来想去，寝食难安。 问题的关键究竟为何？ 每个人都不得不面对这些问题。 在面对这种问题时， 要想清楚，学生会退会，到底是一种怎么样的存在。 我认为， 既然如此， 每个人都不得不面对这些问题。 在面对这种问题时， 那么， 我认为， 学生会退会因何而发生。\n引用 思念是最暖的忧伤像一双翅膀\n让我停不了飞不远在过往游荡\n不告而别的你 就算为了我着想\n这么沉痛的呵护 我怎么能翱翔\n最暖的憂傷 - 田馥甄\n图片 1 2 3 ![Photo by Florian Klauer on Unsplash](florian-klauer-nptLmg6jqDo-unsplash.jpg) ![Photo by Luca Bravo on Unsplash](luca-bravo-alS7ewQ41M8-unsplash.jpg) ![Photo by Helena Hertz on Unsplash](helena-hertz-wWZzXlDpMog-unsplash.jpg) ![Photo by Hudai Gayiran on Unsplash](hudai-gayiran-3Od_VKcDEAA-unsplash.jpg) 相册语法来自 Typlog\n","date":"2020-09-09T00:00:00Z","image":"https://gkxgithub.github.io/p/test-chinese/helena-hertz-wWZzXlDpMog-unsplash_hu4699868770670889127.jpg","permalink":"https://gkxgithub.github.io/p/test-chinese/","title":"Chinese Test"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n— Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code A B C D E F Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus ultricies, sapien non euismod aliquam, dui ligula tincidunt odio, at accumsan nulla sapien eget ex. Proin eleifend dictum ipsum, non euismod ipsum pulvinar et. Vivamus sollicitudin, quam in pulvinar aliquam, metus elit pretium purus Proin sit amet velit nec enim imperdiet vehicula. Ut bibendum vestibulum quam, eu egestas turpis gravida nec Sed scelerisque nec turpis vel viverra. Vivamus vitae pretium sapien Code Blocks Code block with backticks 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block with Hugo\u0026rsquo;s internal highlight shortcode 1 2 3 4 5 6 7 8 9 10 \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Diff code block 1 2 3 4 5 [dependencies.bevy] git = \u0026#34;https://github.com/bevyengine/bevy\u0026#34; rev = \u0026#34;11f52b8c72fc3a568e8bb4a4cd1f3eb025ac2e13\u0026#34; - features = [\u0026#34;dynamic\u0026#34;] + features = [\u0026#34;jpeg\u0026#34;, \u0026#34;dynamic\u0026#34;] List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese Other Elements — abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL + ALT + Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nHyperlinked image The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2019-03-11T00:00:00Z","image":"https://gkxgithub.github.io/p/markdown-syntax-guide/pawel-czerwinski-8uZPynIu-rQ-unsplash_hu6307248181568134095.jpg","permalink":"https://gkxgithub.github.io/p/markdown-syntax-guide/","title":"Markdown Syntax Guide"},{"content":"Lorem est tota propiore conpellat pectoribus de pectora summo.\nRedit teque digerit hominumque toris verebor lumina non cervice subde tollit usus habet Arctonque, furores quas nec ferunt. Quoque montibus nunc caluere tempus inhospita parcite confusaque translucet patri vestro qui optatis lumine cognoscere flos nubis! Fronde ipsamque patulos Dryopen deorum.\nExierant elisi ambit vivere dedere Duce pollice Eris modo Spargitque ferrea quos palude Rursus nulli murmur; hastile inridet ut ab gravi sententia! Nomine potitus silentia flumen, sustinet placuit petis in dilapsa erat sunt. Atria tractus malis.\nComas hunc haec pietate fetum procerum dixit Post torum vates letum Tiresia Flumen querellas Arcanaque montibus omnes Quidem et Vagus elidunt The Van de Graaf Canon\nMane refeci capiebant unda mulcebat Victa caducifer, malo vulnere contra dicere aurato, ludit regale, voca! Retorsit colit est profanae esse virescere furit nec; iaculi matertera et visa est, viribus. Divesque creatis, tecta novat collumque vulnus est, parvas. Faces illo pepulere tempus adest. Tendit flamma, ab opes virum sustinet, sidus sequendo urbis.\nIubar proles corpore raptos vero auctor imperium; sed et huic: manus caeli Lelegas tu lux. Verbis obstitit intus oblectamina fixis linguisque ausus sperare Echionides cornuaque tenent clausit possit. Omnia putatur. Praeteritae refert ausus; ferebant e primus lora nutat, vici quae mea ipse. Et iter nil spectatae vulnus haerentia iuste et exercebat, sui et.\nEurytus Hector, materna ipsumque ut Politen, nec, nate, ignari, vernum cohaesit sequitur. Vel mitis temploque vocatus, inque alis, oculos nomen non silvis corpore coniunx ne displicet illa. Crescunt non unus, vidit visa quantum inmiti flumina mortis facto sic: undique a alios vincula sunt iactata abdita! Suspenderat ego fuit tendit: luna, ante urbem Propoetides parte.\n","date":"2019-03-09T00:00:00Z","image":"https://gkxgithub.github.io/p/placeholder-text/matt-le-SJSpo9hQf7s-unsplash_hu10664154974910995856.jpg","permalink":"https://gkxgithub.github.io/p/placeholder-text/","title":"Placeholder Text"},{"content":"Mathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\nIn this example we will be using KaTeX\nCreate a partial under /layouts/partials/math.html Within this partial reference the Auto-render Extension or host these scripts locally. Include the partial in your templates like so: 1 2 3 {{ if or .Params.math .Site.Params.math }} {{ partial \u0026#34;math.html\u0026#34; . }} {{ end }} To enable KaTeX globally set the parameter math to true in a project\u0026rsquo;s configuration To enable KaTeX on a per page basis include the parameter math: true in content files Note: Use the online reference of Supported TeX Functions\nExamples Inline math: $\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887…$\nBlock math: $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$\n","date":"2019-03-08T00:00:00Z","permalink":"https://gkxgithub.github.io/p/math-typesetting/","title":"Math Typesetting"},{"content":"Emoji can be enabled in a Hugo project in a number of ways.\nThe emojify function can be called directly in templates or Inline Shortcodes.\nTo enable emoji globally, set enableEmoji to true in your site\u0026rsquo;s configuration and then you can type emoji shorthand codes directly in content files; e.g.\n🙈 :see_no_evil: 🙉 :hear_no_evil: 🙊 :speak_no_evil:\nThe Emoji cheat sheet is a useful reference for emoji shorthand codes.\nN.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.\n1 2 3 .emoji { font-family: Apple Color Emoji, Segoe UI Emoji, NotoColorEmoji, Segoe UI Symbol, Android Emoji, EmojiSymbols; } ","date":"2019-03-05T00:00:00Z","image":"https://gkxgithub.github.io/p/emoji-support/the-creative-exchange-d2zvqp3fpro-unsplash_hu5876398126655421130.jpg","permalink":"https://gkxgithub.github.io/p/emoji-support/","title":"Emoji Support"}]